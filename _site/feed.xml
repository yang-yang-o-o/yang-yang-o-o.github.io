<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2024-05-31T10:44:03+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Yang yang</title><entry><title type="html">传感器</title><link href="http://localhost:4000/%E4%BC%A0%E6%84%9F%E5%99%A8/" rel="alternate" type="text/html" title="传感器" /><published>2022-12-28T23:38:00+08:00</published><updated>2022-12-28T23:38:00+08:00</updated><id>http://localhost:4000/%E4%BC%A0%E6%84%9F%E5%99%A8</id><content type="html" xml:base="http://localhost:4000/%E4%BC%A0%E6%84%9F%E5%99%A8/">&lt;h2 id=&quot;目录&quot;&gt;目录&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h3 id=&quot;1单目相机&quot;&gt;&lt;a href=&quot;#customname1&quot;&gt;1、单目相机&lt;/a&gt;&lt;/h3&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h3 id=&quot;2鱼眼相机&quot;&gt;&lt;a href=&quot;#customname2&quot;&gt;2、鱼眼相机&lt;/a&gt;&lt;/h3&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h3 id=&quot;3深度相机&quot;&gt;&lt;a href=&quot;#customname3&quot;&gt;3、深度相机&lt;/a&gt;&lt;/h3&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h3 id=&quot;4激光雷达&quot;&gt;&lt;a href=&quot;#customname4&quot;&gt;4、激光雷达&lt;/a&gt;&lt;/h3&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h3 id=&quot;5imu&quot;&gt;&lt;a href=&quot;#customname5&quot;&gt;5、IMU&lt;/a&gt;&lt;/h3&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;customname1&quot;&gt;1、单目相机&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;成像过程&quot;&gt;成像过程&lt;/h4&gt;

    &lt;p&gt;四种坐标：世界、相机、归一化相机和像素坐标&lt;/p&gt;

    &lt;p&gt;&lt;!-- ![Markdowm Image](/assets\sensor\image_16.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\sensor\image_16.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;&lt;!-- ![Markdowm Image](/assets\sensor\image_17.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\sensor\image_17.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;&lt;!-- ![Markdowm Image](/assets\sensor\image_18.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\sensor\image_18.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;fx和fy的物理意义：归一化平面上一个单位距离，在图像上占多少个像素&lt;/p&gt;

    &lt;p&gt;&lt;!-- ![Markdowm Image](/assets\sensor\image_19.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\sensor\image_19.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;&lt;!-- ![Markdowm Image](/assets\sensor\image_20.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\sensor\image_20.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;&lt;!-- ![Markdowm Image](/assets\sensor\image_21.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\sensor\image_21.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;&lt;!-- ![Markdowm Image](/assets\sensor\image_22.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\sensor\image_22.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;注意到Z 可能小于1，说明该点位于归一化平面后面，它可能不会在相机平面上成像，实践当中要检查一次。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;畸变矫正过程&quot;&gt;畸变矫正过程&lt;/h4&gt;

    &lt;p&gt;&lt;!-- ![Markdowm Image](/assets\sensor\image_23.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\sensor\image_23.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;customname2&quot;&gt;2、鱼眼相机&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;鱼眼镜头&quot;&gt;鱼眼镜头&lt;/h4&gt;

    &lt;p&gt;个人认为针孔相机模型和鱼眼相机模型区别在于光线传播的不同，前者是直线传播，射线在归一化平面上的交点就是成像点，而后者存在折射，折射后在归一化平面上的成像点比针孔模型成像点更接近z轴，从而使得在成像面尺寸不变的情况下，鱼眼相机模型可以获得更大的fov角度。
  &lt;!-- ![Markdowm Image](/assets\sensor\image_24.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\sensor\image_24.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;&lt;!-- ![Markdowm Image](/assets\sensor\image_25.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\sensor\image_25.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;投影模型&quot;&gt;投影模型&lt;/h4&gt;

    &lt;p&gt;&lt;!-- ![Markdowm Image](/assets\sensor\image_26.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\sensor\image_26.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;&lt;!-- ![Markdowm Image](/assets\sensor\image_27.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\sensor\image_27.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;成像过程-1&quot;&gt;成像过程&lt;/h4&gt;

    &lt;p&gt;&lt;!-- ![Markdowm Image](/assets\sensor\image_28.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\sensor\image_28.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;这个图一个不合适的地方是，a，b，xd，yd应该标在归一化平面内，且分别为N和M在归一化平面内的坐标。&lt;/p&gt;

    &lt;p&gt;&lt;!-- ![Markdowm Image](/assets\sensor\image_29.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\sensor\image_29.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;两种猜测，后续有待具体确认，公式 (1) 可能是因为投影模型是fθ，然后再乘上畸变矫正；也可能是这个 (1+…) 是畸变矫正和投影模型的耦合，因为鱼眼投影的折射也可以看成是一种相对于小孔投影的畸变，这样的话，投影模型就可以直接同时和畸变一起在相机标定的过程中被拟合出来。&lt;/p&gt;

    &lt;p&gt;&lt;!-- ![Markdowm Image](/assets\sensor\image_30.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\sensor\image_30.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;fov对比&quot;&gt;fov对比&lt;/h4&gt;

    &lt;p&gt;&lt;!-- ![Markdowm Image](/assets\sensor\image_31.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\sensor\image_31.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;假设都在归一化平面内，焦距f等于1，此时纵坐标表示归一化平面内的成像半径，可以看出，对于入射角为90度（垂直于光轴）的光线，小孔投影的成像半径是无穷大，而其他的几种鱼眼模型的成像半径都在2以内，此时fov角为180度。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;参考&quot;&gt;参考&lt;/h4&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;主要参考&lt;/p&gt;

        &lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/655174655&quot;&gt;深入洞察OpenCV鱼眼模型之成像投影和畸变表估计系数相互转化-知乎(zhihu.com)&lt;/a&gt;&lt;br /&gt;
  &lt;a href=&quot;https://blog.csdn.net/qq_44876051/article/details/125835562&quot;&gt;【鱼眼相机模型】鱼眼相机投影模型理解-CSDN博客&lt;/a&gt;&lt;br /&gt;
  &lt;a href=&quot;https://blog.csdn.net/qq_16137569/article/details/112398976&quot;&gt;鱼眼镜头的成像原理到畸变矫正（完整版）_鱼眼畸变-CSDN博客&lt;/a&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;其他参考&lt;/p&gt;

        &lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/584328948&quot;&gt;环视近场感知系列之鱼眼相机模型-知乎(zhihu.com)&lt;/a&gt;&lt;br /&gt;
  &lt;a href=&quot;https://zhuanlan.zhihu.com/p/340751380&quot;&gt;鱼眼相机模型-知乎(zhihu.com)&lt;/a&gt;&lt;br /&gt;
  &lt;a href=&quot;https://zhuanlan.zhihu.com/p/511284263&quot;&gt;一文详解分析鱼眼相机投影成像模型和畸变模型-知乎(zhihu.com)&lt;/a&gt;&lt;br /&gt;
  &lt;a href=&quot;https://docs.opencv.org/3.4/db/d58/group__calib3d__fisheye.html&quot;&gt;OpenCV:Fisheye_camera_model&lt;/a&gt;&lt;br /&gt;
  &lt;a href=&quot;https://massive11.github.io/2022/09/12/principle-xiang-ji-cheng-xiang-ji-bian-mo-xing/&quot;&gt;相机成像畸变模型与鱼眼相机模型|Untitled.(massive11.github.io)&lt;/a&gt;&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;customname3&quot;&gt;3、深度相机&lt;/h3&gt;

&lt;p&gt;深度相机的工作原理可以通过以下几种常见的技术来实现：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;结构光-structured-light-技术&quot;&gt;结构光 (Structured Light) 技术：&lt;/h4&gt;
    &lt;p&gt;深度相机通过投射结构化的光源（通常是红外光）到场景上，例如使用一种特殊的光栅或编码模式。当光线与场景中的物体相交时，光线会发生形变。通过观察投影到物体上的形变图案，深度相机可以计算出物体的距离。这种技术常用于基于三角测量原理的深度测量。&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;
        &lt;h5 id=&quot;优点&quot;&gt;优点：&lt;/h5&gt;
        &lt;ul&gt;
          &lt;li&gt;&lt;strong&gt;高精度&lt;/strong&gt;：近距离(1米内)精度较高，毫米/亚毫米级。测量范围广、对光线和颜色的敏感度低等。主动投影，适合弱光照使用。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;h5 id=&quot;缺点&quot;&gt;缺点：&lt;/h5&gt;
        &lt;ul&gt;
          &lt;li&gt;&lt;strong&gt;有限的测量范围&lt;/strong&gt;：测量距离和分辨率存在一定的局限性。远距离精度差，随着距离的拉长，精度也随之变差。&lt;/li&gt;
          &lt;li&gt;&lt;strong&gt;受环境光影响&lt;/strong&gt;：对环境光的干扰较大，室外强光照不宜使用，强光容易干扰投影光。&lt;/li&gt;
          &lt;li&gt;&lt;strong&gt;对透明物体和反射面的挑战&lt;/strong&gt;：由于结构光深度相机是通过观察光线的反射和形变来计算深度，透明物体或具有高反射性的表面可能会引起测量的困难。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;飞行时间-time-of-flight-tof-技术&quot;&gt;飞行时间 (Time-of-Flight, TOF) 技术：&lt;/h4&gt;
    &lt;p&gt;深度相机通过发射一个脉冲光源（通常是红外光）并测量光线从相机发射到物体上的反射和返回所需的时间。根据光的速度和返回时间，深度相机可以计算出物体到相机的距离。这种技术利用了光的传播速度和时间测量原理。&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;
        &lt;h5 id=&quot;优点-1&quot;&gt;优点：&lt;/h5&gt;
        &lt;ul&gt;
          &lt;li&gt;
            &lt;p&gt;&lt;strong&gt;不依赖光源&lt;/strong&gt;：因为是依靠投射自身光线的技术，所以它不需要任何外部光源来扫描周围环境，即使在光线很少或没有光线的情况下也能正常工作。&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;&lt;strong&gt;大范围测量&lt;/strong&gt;：TOF的测量距离较远，不受表面灰度和特征影响，达百米，深度距离计算，不会随距离的变化而变化，稳定在厘米级&lt;/p&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;h5 id=&quot;缺点-1&quot;&gt;缺点：&lt;/h5&gt;
        &lt;ul&gt;
          &lt;li&gt;&lt;strong&gt;易受环境光、介质、物体表面反射率影响&lt;/strong&gt;：对环境的光强和干扰比较敏感，室外强光照基本不能使用。由于基于飞行时间的技术依赖于发射和接收自身光的反向反射，因此在自然环境中（例如暴露在阳光下）它们可能表现不佳，这是因为其他光源发出的波会干扰相机设备发出的光。类似地，还有其他因素使ToF传感器更难正常工作，如“反光”表面（在不同方向反射光）或角落（产生多次反射）等。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;双目视觉-stereo-vision-技术&quot;&gt;双目视觉 (Stereo Vision) 技术：&lt;/h4&gt;
    &lt;p&gt;深度相机通过两个相机（左眼和右眼）来模拟人类的双眼视觉。通过观察左右两个相机拍摄到的图像中物体的视差（左右图像中对应点的像素偏移），深度相机可以计算出物体到相机的距离。这种技术基于三角测量原理和立体视觉的概念。&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;
        &lt;h5 id=&quot;优点-2&quot;&gt;优点：&lt;/h5&gt;
        &lt;ul&gt;
          &lt;li&gt;&lt;strong&gt;成本低&lt;/strong&gt;：不需要结构光、TOF的发射器和接收器，因此结构简单硬件成本低，适合成本敏感的应用场景。&lt;/li&gt;
          &lt;li&gt;&lt;strong&gt;适应不同的环境&lt;/strong&gt;：因为依靠自然光，可在室内外使用。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;h5 id=&quot;缺点-2&quot;&gt;缺点：&lt;/h5&gt;
        &lt;ul&gt;
          &lt;li&gt;&lt;strong&gt;有限的测量范围&lt;/strong&gt;：立体视觉深度相机的测量范围通常有限，远离相机或深度变化较大的物体可能无法准确测量。&lt;/li&gt;
          &lt;li&gt;&lt;strong&gt;依赖纹理和特征&lt;/strong&gt;：立体视觉深度相机对于纹理丰富的物体和有明显特征的场景效果更好，对于纹理缺乏或特征不明显的物体可能测量不准确。&lt;/li&gt;
          &lt;li&gt;&lt;strong&gt;计算复杂度&lt;/strong&gt;：立体视觉深度相机需要进行立体匹配和深度计算，涉及较复杂的图像处理和计算，对计算资源要求较高。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;customname4&quot;&gt;4、激光雷达&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;原理&quot;&gt;原理&lt;/h4&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;h5 id=&quot;1飞行时间tof探测方法&quot;&gt;1、飞行时间（ToF）探测方法&lt;/h5&gt;

        &lt;p&gt;通过直接计算发射及接收电磁波的时间差测量被测目标的距离；
  &lt;!-- ![Markdowm Image](/assets\sensor\image_0.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\sensor\image_0.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;h5 id=&quot;2相干探测方法如fmcw&quot;&gt;2、相干探测方法（如：FMCW）&lt;/h5&gt;

        &lt;p&gt;通过测量发射电磁波与返回电磁波的频率变化解调出被测目标的距离及速度；
  &lt;!-- ![Markdowm Image](/assets\sensor\image_1.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\sensor\image_1.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;fov&quot;&gt;FOV&lt;/h4&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;垂直FOV&lt;/strong&gt;：常见的车载激光雷达通常在25°，形状呈扇形；&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;水平FOV&lt;/strong&gt;：常见的机械式激光雷达可以达到360°范围，通常布置于车顶；常见的车载半固态激光雷达通常可以达到120°范围，形状呈扇形，可布置于车身或车顶；&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;种类&quot;&gt;种类&lt;/h4&gt;

    &lt;p&gt;把激光雷达按照扫描方式来分类，目前有机械式激光雷达、半固态激光雷达和固态激光雷达三大类。其中机械式激光雷达最为常用，固态激光雷达为未来业界大力发展方向，半固态激光雷达是机械式和纯固态式的折中方案，属于目前阶段量产装车的主力军。
  &lt;!-- ![Markdowm Image](/assets\sensor\image_2.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\sensor\image_2.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h5 id=&quot;机械式激光雷达&quot;&gt;机械式激光雷达&lt;/h5&gt;

    &lt;p&gt;&lt;!-- ![Markdowm Image](/assets\sensor\0.webp) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\sensor\0.webp&quot; alt=&quot;Markdowm Image&quot; /&gt;
  &lt;!-- ![Markdowm Image](/assets\sensor\image_3.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\sensor\image_3.png&quot; alt=&quot;Markdowm Image&quot; /&gt;
  &lt;!-- ![Markdowm Image](/assets\sensor\image_4.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\sensor\image_4.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h5 id=&quot;半固态mems式激光雷达&quot;&gt;半固态—MEMS式激光雷达&lt;/h5&gt;

    &lt;p&gt;&lt;!-- ![Markdowm Image](/assets\sensor\1.webp) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\sensor\1.webp&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;&lt;!-- ![Markdowm Image](/assets\sensor\2.webp) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\sensor\2.webp&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;&lt;!-- ![Markdowm Image](/assets\sensor\image_5.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\sensor\image_5.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h5 id=&quot;半固态转镜式激光雷达&quot;&gt;半固态—转镜式激光雷达&lt;/h5&gt;

    &lt;p&gt;&lt;!-- ![Markdowm Image](/assets\sensor\3.gif) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\sensor\3.gif&quot; alt=&quot;Markdowm Image&quot; /&gt;
  &lt;!-- ![Markdowm Image](/assets\sensor\image_6.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\sensor\image_6.png&quot; alt=&quot;Markdowm Image&quot; /&gt;
  &lt;!-- ![Markdowm Image](/assets\sensor\image_7.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\sensor\image_7.png&quot; alt=&quot;Markdowm Image&quot; /&gt;
  &lt;!-- ![Markdowm Image](/assets\sensor\image_8.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\sensor\image_8.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h5 id=&quot;半固态-棱镜式激光雷达&quot;&gt;半固态-棱镜式激光雷达&lt;/h5&gt;
    &lt;p&gt;&lt;!-- ![Markdowm Image](/assets\sensor\image_9.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\sensor\image_9.png&quot; alt=&quot;Markdowm Image&quot; /&gt;
  &lt;!-- ![Markdowm Image](/assets\sensor\4.gif) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\sensor\4.gif&quot; alt=&quot;Markdowm Image&quot; /&gt;
  &lt;!-- ![Markdowm Image](/assets\sensor\image_10.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\sensor\image_10.png&quot; alt=&quot;Markdowm Image&quot; /&gt;
  &lt;!-- ![Markdowm Image](/assets\sensor\image_11.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\sensor\image_11.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h5 id=&quot;固态-opa激光雷达&quot;&gt;固态-OPA激光雷达&lt;/h5&gt;

    &lt;p&gt;&lt;!-- ![Markdowm Image](/assets\sensor\5.webp) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\sensor\5.webp&quot; alt=&quot;Markdowm Image&quot; /&gt;
  &lt;!-- ![Markdowm Image](/assets\sensor\6.gif) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\sensor\6.gif&quot; alt=&quot;Markdowm Image&quot; /&gt;
  &lt;!-- ![Markdowm Image](/assets\sensor\image_12.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\sensor\image_12.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h5 id=&quot;固态-flash激光雷达&quot;&gt;固态-FLASH激光雷达&lt;/h5&gt;

    &lt;p&gt;&lt;!-- ![Markdowm Image](/assets\sensor\image_13.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\sensor\image_13.png&quot; alt=&quot;Markdowm Image&quot; /&gt;
  &lt;!-- ![Markdowm Image](/assets\sensor\image_14.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\sensor\image_14.png&quot; alt=&quot;Markdowm Image&quot; /&gt;
  &lt;!-- ![Markdowm Image](/assets\sensor\image_15.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\sensor\image_15.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;参考-1&quot;&gt;参考&lt;/h4&gt;

    &lt;p&gt;https://zhuanlan.zhihu.com/p/602055107&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;customname5&quot;&gt;5、IMU&lt;/h3&gt;

&lt;p&gt;IMU是惯性测量单元（Inertial Measurement Unit）的缩写，它是一种集成了多个惯性传感器的装置，用于测量和跟踪物体的姿态、加速度和角速度等运动参数。IMU通常由以下几个主要惯性传感器组成：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;加速度计（Accelerometer）：
  加速度计测量物体的加速度，即物体在空间中的线性加速度。它基于质量和力的关系，通过测量物体在三个坐标轴上的加速度来推导出物体的姿态和运动状态。&lt;/li&gt;
  &lt;li&gt;陀螺仪（Gyroscope）：
  陀螺仪测量物体的角速度，即物体围绕三个坐标轴旋转的速率。它通过感知角动量定理，测量物体在各个轴向上的角速度，从而提供物体的旋转信息。&lt;/li&gt;
  &lt;li&gt;磁力计（Magnetometer）：
  磁力计测量物体周围的磁场强度，用于确定物体的方向和姿态。磁力计通常用于辅助姿态估计，并提供物体相对于地球磁场的定向信息。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;最终输出信息&lt;/strong&gt;：
    姿态欧拉角、角速度、角加速度、三个坐标轴的线加速度&lt;/p&gt;</content><author><name></name></author><category term="blog" /><category term="SLAM" /><summary type="html">目录</summary></entry><entry><title type="html">VSlam</title><link href="http://localhost:4000/VSlam/" rel="alternate" type="text/html" title="VSlam" /><published>2022-12-27T23:38:00+08:00</published><updated>2022-12-27T23:38:00+08:00</updated><id>http://localhost:4000/VSlam</id><content type="html" xml:base="http://localhost:4000/VSlam/">&lt;h2 id=&quot;目录&quot;&gt;目录&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h3 id=&quot;1slam概述&quot;&gt;&lt;a href=&quot;#customname1&quot;&gt;1、SLAM概述&lt;/a&gt;&lt;/h3&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h3 id=&quot;2基础知识&quot;&gt;&lt;a href=&quot;#customname2&quot;&gt;2、基础知识&lt;/a&gt;&lt;/h3&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;h4 id=&quot;21刚体运动&quot;&gt;&lt;a href=&quot;#customname2_1&quot;&gt;2.1、刚体运动&lt;/a&gt;&lt;/h4&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;h4 id=&quot;22李群李代数&quot;&gt;&lt;a href=&quot;#customname2_2&quot;&gt;2.2、李群李代数&lt;/a&gt;&lt;/h4&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;h4 id=&quot;23相机模型&quot;&gt;&lt;a href=&quot;#customname2_3&quot;&gt;2.3、相机模型&lt;/a&gt;&lt;/h4&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;h4 id=&quot;24非线性优化&quot;&gt;&lt;a href=&quot;#customname2_4&quot;&gt;2.4、非线性优化&lt;/a&gt;&lt;/h4&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h3 id=&quot;3前端视觉里程计visual-odometry-vo&quot;&gt;&lt;a href=&quot;#customname3&quot;&gt;3、前端/视觉里程计(Visual Odometry, VO)&lt;/a&gt;&lt;/h3&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;h4 id=&quot;31特征点法&quot;&gt;&lt;a href=&quot;#customname3_1&quot;&gt;3.1、特征点法&lt;/a&gt;&lt;/h4&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;h4 id=&quot;32光流法&quot;&gt;&lt;a href=&quot;#customname3_2&quot;&gt;3.2、光流法&lt;/a&gt;&lt;/h4&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;h4 id=&quot;33直接法&quot;&gt;&lt;a href=&quot;#customname3_3&quot;&gt;3.3、直接法&lt;/a&gt;&lt;/h4&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h3 id=&quot;4后端非线性优化optimization&quot;&gt;&lt;a href=&quot;#customname4&quot;&gt;4、后端/非线性优化(Optimization)&lt;/a&gt;&lt;/h3&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;h4 id=&quot;41基于滤波器&quot;&gt;&lt;a href=&quot;#customname4_1&quot;&gt;4.1、基于滤波器&lt;/a&gt;&lt;/h4&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;h4 id=&quot;42基于非线性优化&quot;&gt;&lt;a href=&quot;#customname4_2&quot;&gt;4.2、基于非线性优化&lt;/a&gt;&lt;/h4&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h3 id=&quot;5回环检测loop-closing&quot;&gt;&lt;a href=&quot;#customname5&quot;&gt;5、回环检测(Loop Closing)&lt;/a&gt;&lt;/h3&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;h4 id=&quot;51词袋模型&quot;&gt;&lt;a href=&quot;#customname5_1&quot;&gt;5.1、词袋模型&lt;/a&gt;&lt;/h4&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;h4 id=&quot;52字典&quot;&gt;&lt;a href=&quot;#customname5_2&quot;&gt;5.2、字典&lt;/a&gt;&lt;/h4&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;h4 id=&quot;53相似度计算&quot;&gt;&lt;a href=&quot;#customname5_3&quot;&gt;5.3、相似度计算&lt;/a&gt;&lt;/h4&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h3 id=&quot;6建图&quot;&gt;&lt;a href=&quot;#customname6&quot;&gt;6、建图&lt;/a&gt;&lt;/h3&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;h4 id=&quot;61单目稠密重建&quot;&gt;&lt;a href=&quot;#customname6_1&quot;&gt;6.1、单目稠密重建&lt;/a&gt;&lt;/h4&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;h4 id=&quot;62rgb-d稠密建图&quot;&gt;&lt;a href=&quot;#customname6_2&quot;&gt;6.2、RGB-D稠密建图&lt;/a&gt;&lt;/h4&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;customname1&quot;&gt;1、SLAM概述&lt;/h3&gt;

&lt;!-- ![Markdowm Image](/assets\VSlam\image_1.png) --&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_1.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;customname2&quot;&gt;2、基础知识&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;customname2_1&quot;&gt;2.1、刚体运动&lt;/h4&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;h5 id=&quot;欧式变换&quot;&gt;欧式变换&lt;/h5&gt;

        &lt;p&gt;&lt;!-- ![Markdowm Image](/assets\VSlam\image_1_1.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_1_1.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;
            &lt;p&gt;&lt;strong&gt;旋转矩阵&lt;/strong&gt;&lt;/p&gt;

            &lt;p&gt;&lt;!-- ![Markdowm Image](/assets\VSlam\image_2.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_2.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;&lt;strong&gt;旋转向量&lt;/strong&gt;&lt;/p&gt;

            &lt;p&gt;&lt;!-- ![Markdowm Image](/assets\VSlam\image_3.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_3.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;&lt;strong&gt;欧拉角&lt;/strong&gt;&lt;/p&gt;

            &lt;p&gt;&lt;!-- ![Markdowm Image](/assets\VSlam\image_4.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_4.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;&lt;strong&gt;四元素&lt;/strong&gt;&lt;/p&gt;

            &lt;ul&gt;
              &lt;li&gt;
                &lt;p&gt;定义
  &lt;!-- ![Markdowm Image](/assets\VSlam\image_5.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_5.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;
              &lt;/li&gt;
              &lt;li&gt;
                &lt;p&gt;运算
  &lt;!-- ![Markdowm Image](/assets\VSlam\image_6.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_6.png&quot; alt=&quot;Markdowm Image&quot; /&gt;
  &lt;!-- ![Markdowm Image](/assets\VSlam\image_7.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_7.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;
              &lt;/li&gt;
              &lt;li&gt;
                &lt;p&gt;四元数表示旋转
  &lt;!-- ![Markdowm Image](/assets\VSlam\image_8.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_8.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;
              &lt;/li&gt;
              &lt;li&gt;
                &lt;p&gt;四元数 &amp;lt;—&amp;gt; 旋转向量
  &lt;!-- ![Markdowm Image](/assets\VSlam\image_9.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_9.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;
              &lt;/li&gt;
              &lt;li&gt;
                &lt;p&gt;四元数 &amp;lt;—&amp;gt; 旋转矩阵
  &lt;!-- ![Markdowm Image](/assets\VSlam\image_10.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_10.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;相似变换&lt;/strong&gt;&lt;/p&gt;

        &lt;p&gt;相似变换比欧式变换多了一个自由度，它允许物体进行均匀的缩放，缩放因子 $s$
  &lt;!-- ![Markdowm Image](/assets\VSlam\image_11.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_11.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;仿射变换&lt;/strong&gt;&lt;/p&gt;

        &lt;p&gt;仿射变换只要求A是一个可逆矩阵，而欧式变换要求是正交矩阵
  &lt;!-- ![Markdowm Image](/assets\VSlam\image_12.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_12.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;摄影变换&lt;/strong&gt;
  摄影变换是更一般的变换，在仿射变换基础上增加了 $a^T$ 和 $v$
  &lt;!-- ![Markdowm Image](/assets\VSlam\image_13.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_13.png&quot; alt=&quot;Markdowm Image&quot; /&gt;
  $a^T$和𝑣的选择可以引入投影或其他非线性变换。$a^T$影响变换的透视性质，𝑣作为标量缩放因子
  &lt;!-- ![Markdowm Image](/assets\VSlam\image_14.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_14.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;customname2_2&quot;&gt;2.2、李群李代数&lt;/h4&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;李群&lt;/p&gt;

        &lt;p&gt;&lt;!-- ![Markdowm Image](/assets\VSlam\image_15.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_15.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;李代数&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;每个李群都有对应的李代数，李代数描述了李群的局部性质。&lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;李代数作用：通过李群——李代数间的转换关系，把位姿估计变成无约束的优化问题，简化求解方式。因为R正交且行列式为1，直接优化R是困难的，会引入约束&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;&lt;strong&gt;引出&lt;/strong&gt;
  &lt;!-- ![Markdowm Image](/assets\VSlam\image_16.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_16.png&quot; alt=&quot;Markdowm Image&quot; /&gt;
  &lt;!-- ![Markdowm Image](/assets\VSlam\image_17.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_17.png&quot; alt=&quot;Markdowm Image&quot; /&gt;
  &lt;!-- ![Markdowm Image](/assets\VSlam\image_18.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_18.png&quot; alt=&quot;Markdowm Image&quot; /&gt;
  &lt;!-- ![Markdowm Image](/assets\VSlam\image_19.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_19.png&quot; alt=&quot;Markdowm Image&quot; /&gt;
  是否可以这么理解：一个旋转矩阵左乘由他的旋转向量构成的反对称矩阵，就得到了这个旋转矩阵的导数，其中旋转向量：Φ = θα ，θ为旋转向量的旋转角，α为旋转向量的单位旋转轴&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;&lt;strong&gt;定义&lt;/strong&gt;&lt;/p&gt;

            &lt;p&gt;&lt;!-- ![Markdowm Image](/assets\VSlam\image_20.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_20.png&quot; alt=&quot;Markdowm Image&quot; /&gt;
  &lt;!-- ![Markdowm Image](/assets\VSlam\image_21.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_21.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;指数映射、对数映射&lt;/p&gt;

        &lt;p&gt;&lt;!-- ![Markdowm Image](/assets\VSlam\image_22.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_22.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

        &lt;p&gt;&lt;!-- ![Markdowm Image](/assets\VSlam\image_23.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_23.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

        &lt;p&gt;&lt;!-- ![Markdowm Image](/assets\VSlam\image_24.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_24.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;扰动模型&lt;/p&gt;

        &lt;p&gt;&lt;!-- ![Markdowm Image](/assets\VSlam\image_25.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_25.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;customname2_3&quot;&gt;2.3、相机模型&lt;/h4&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;单目相机&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;
            &lt;p&gt;成像模型&lt;/p&gt;

            &lt;p&gt;&lt;!-- ![Markdowm Image](/assets\VSlam\image_26.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_26.png&quot; alt=&quot;Markdowm Image&quot; /&gt;
  &lt;!-- ![Markdowm Image](/assets\VSlam\image_27.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_27.png&quot; alt=&quot;Markdowm Image&quot; /&gt;
  &lt;!-- ![Markdowm Image](/assets\VSlam\image_28.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_28.png&quot; alt=&quot;Markdowm Image&quot; /&gt;
  &lt;!-- ![Markdowm Image](/assets\VSlam\image_29.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_29.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;畸变&lt;/p&gt;

            &lt;p&gt;&lt;!-- ![Markdowm Image](/assets\VSlam\image_30.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_30.png&quot; alt=&quot;Markdowm Image&quot; /&gt;
  &lt;!-- ![Markdowm Image](/assets\VSlam\image_31.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_31.png&quot; alt=&quot;Markdowm Image&quot; /&gt;
  &lt;!-- ![Markdowm Image](/assets\VSlam\image_32.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_32.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;双目相机&lt;/p&gt;

        &lt;p&gt;&lt;!-- ![Markdowm Image](/assets\VSlam\image_33.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_33.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;RGBD相机&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;
            &lt;p&gt;红外结构光&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;TOF&lt;/p&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;customname2_4&quot;&gt;2.4、非线性优化&lt;/h4&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;一阶和二阶梯度法&lt;/p&gt;

        &lt;p&gt;&lt;!-- ![Markdowm Image](/assets\VSlam\image_34.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_34.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Gauss-Newton&lt;/p&gt;

        &lt;p&gt;&lt;!-- ![Markdowm Image](/assets\VSlam\image_35.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_35.png&quot; alt=&quot;Markdowm Image&quot; /&gt;
  &lt;!-- ![Markdowm Image](/assets\VSlam\image_36.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_36.png&quot; alt=&quot;Markdowm Image&quot; /&gt;
  &lt;!-- ![Markdowm Image](/assets\VSlam\image_37.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_37.png&quot; alt=&quot;Markdowm Image&quot; /&gt;
  &lt;!-- ![Markdowm Image](/assets\VSlam\image_38.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_38.png&quot; alt=&quot;Markdowm Image&quot; /&gt;
  &lt;!-- ![Markdowm Image](/assets\VSlam\image_39.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_39.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Levenberg-Marquadt&lt;/p&gt;

        &lt;p&gt;&lt;!-- ![Markdowm Image](/assets\VSlam\image_40.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_40.png&quot; alt=&quot;Markdowm Image&quot; /&gt;
  &lt;!-- ![Markdowm Image](/assets\VSlam\image_41.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_41.png&quot; alt=&quot;Markdowm Image&quot; /&gt;
  &lt;!-- ![Markdowm Image](/assets\VSlam\image_42.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_42.png&quot; alt=&quot;Markdowm Image&quot; /&gt;
  &lt;!-- ![Markdowm Image](/assets\VSlam\image_43.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_43.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Ceres库&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;Ceres 库面向通用的最小二乘问题的求解，作为用户，我们需要做的就是定义优化问题，然后设置一些选项，输入进Ceres 求解即可&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;G2O (General Graphic Optimization)&lt;/p&gt;

        &lt;p&gt;&lt;!-- ![Markdowm Image](/assets\VSlam\image_44.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_44.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;customname3&quot;&gt;3、前端/视觉里程计(Visual Odometry, VO)&lt;/h3&gt;

&lt;!-- ![Markdowm Image](/assets\VSlam\image_45.png) --&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_45.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;customname3_1&quot;&gt;3.1、特征点法&lt;/h4&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;特征点：
  由关键点（Key-point）和描述子（Descriptor）两部分组成&lt;/p&gt;

        &lt;p&gt;描述子是按照“外观相似的特征应该有相似的描述子”的原则设计的&lt;/p&gt;

        &lt;p&gt;&lt;!-- ![Markdowm Image](/assets\VSlam\image_46.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_46.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;2D-2D：对极几何&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;
            &lt;p&gt;根据2D点对估计 E /  F  /  H&lt;/p&gt;

            &lt;ul&gt;
              &lt;li&gt;
                &lt;p&gt;对极约束&lt;/p&gt;

                &lt;p&gt;&lt;!-- ![Markdowm Image](/assets\VSlam\image_51.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_51.png&quot; alt=&quot;Markdowm Image&quot; /&gt;
  &lt;!-- ![Markdowm Image](/assets\VSlam\image_52.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_52.png&quot; alt=&quot;Markdowm Image&quot; /&gt;
  &lt;!-- ![Markdowm Image](/assets\VSlam\image_53.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_53.png&quot; alt=&quot;Markdowm Image&quot; /&gt;
  &lt;!-- ![Markdowm Image](/assets\VSlam\image_54.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_54.png&quot; alt=&quot;Markdowm Image&quot; /&gt;
  &lt;!-- ![Markdowm Image](/assets\VSlam\image_55.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_55.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;
              &lt;/li&gt;
              &lt;li&gt;
                &lt;p&gt;本质矩阵  E&lt;/p&gt;

                &lt;p&gt;&lt;!-- ![Markdowm Image](/assets\VSlam\image_56.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_56.png&quot; alt=&quot;Markdowm Image&quot; /&gt;
  &lt;!-- ![Markdowm Image](/assets\VSlam\image_57.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_57.png&quot; alt=&quot;Markdowm Image&quot; /&gt;
  &lt;!-- ![Markdowm Image](/assets\VSlam\image_58.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_58.png&quot; alt=&quot;Markdowm Image&quot; /&gt;
  &lt;!-- ![Markdowm Image](/assets\VSlam\image_59.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_59.png&quot; alt=&quot;Markdowm Image&quot; /&gt;
  &lt;!-- ![Markdowm Image](/assets\VSlam\image_60.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_60.png&quot; alt=&quot;Markdowm Image&quot; /&gt;
  &lt;!-- ![Markdowm Image](/assets\VSlam\image_61.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_61.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;
              &lt;/li&gt;
              &lt;li&gt;
                &lt;p&gt;基础矩阵  F&lt;/p&gt;

                &lt;p&gt;&lt;!-- ![Markdowm Image](/assets\VSlam\image_62.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_62.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;
              &lt;/li&gt;
              &lt;li&gt;
                &lt;p&gt;单应矩阵  H&lt;/p&gt;

                &lt;p&gt;&lt;!-- ![Markdowm Image](/assets\VSlam\image_63.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_63.png&quot; alt=&quot;Markdowm Image&quot; /&gt;
  &lt;!-- ![Markdowm Image](/assets\VSlam\image_64.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_64.png&quot; alt=&quot;Markdowm Image&quot; /&gt;
  &lt;!-- ![Markdowm Image](/assets\VSlam\image_65.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_65.png&quot; alt=&quot;Markdowm Image&quot; /&gt;
  &lt;!-- ![Markdowm Image](/assets\VSlam\image_66.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_66.png&quot; alt=&quot;Markdowm Image&quot; /&gt;
  &lt;!-- ![Markdowm Image](/assets\VSlam\image_67.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_67.png&quot; alt=&quot;Markdowm Image&quot; /&gt;
  &lt;!-- ![Markdowm Image](/assets\VSlam\image_68.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_68.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;
              &lt;/li&gt;
              &lt;li&gt;
                &lt;p&gt;讨论&lt;/p&gt;

                &lt;p&gt;&lt;!-- ![Markdowm Image](/assets\VSlam\image_69.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_69.png&quot; alt=&quot;Markdowm Image&quot; /&gt;
  &lt;!-- ![Markdowm Image](/assets\VSlam\image_70.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_70.png&quot; alt=&quot;Markdowm Image&quot; /&gt;
  &lt;!-- ![Markdowm Image](/assets\VSlam\image_71.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_71.png&quot; alt=&quot;Markdowm Image&quot; /&gt;
  &lt;!-- ![Markdowm Image](/assets\VSlam\image_72.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_72.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;三角测量&lt;/p&gt;

            &lt;p&gt;&lt;!-- ![Markdowm Image](/assets\VSlam\image_48.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_48.png&quot; alt=&quot;Markdowm Image&quot; /&gt;
  &lt;!-- ![Markdowm Image](/assets\VSlam\image_49.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_49.png&quot; alt=&quot;Markdowm Image&quot; /&gt;
  &lt;!-- ![Markdowm Image](/assets\VSlam\image_50.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_50.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;2D-3D：PnP
  &lt;!-- ![Markdowm Image](/assets\VSlam\image_47.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_47.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;3D-3D：ICP
        &lt;ul&gt;
          &lt;li&gt;根据两组3D点估计运动&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;缺点：
        &lt;ul&gt;
          &lt;li&gt;关键点的提取与描述子的计算非常耗时&lt;/li&gt;
          &lt;li&gt;使用特征点时，忽略了除特征点以外的所有信息&lt;/li&gt;
          &lt;li&gt;相机有时会运动到特征缺失的地方，往往这些地方没有明显的纹理信息&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;customname3_2&quot;&gt;3.2、光流法&lt;/h4&gt;

    &lt;p&gt;&lt;!-- ![Markdowm Image](/assets\VSlam\image_73.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_73.png&quot; alt=&quot;Markdowm Image&quot; /&gt;
  &lt;!-- ![Markdowm Image](/assets\VSlam\image_74.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_74.png&quot; alt=&quot;Markdowm Image&quot; /&gt;
  &lt;!-- ![Markdowm Image](/assets\VSlam\image_75.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_75.png&quot; alt=&quot;Markdowm Image&quot; /&gt;
  &lt;!-- ![Markdowm Image](/assets\VSlam\image_76.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_76.png&quot; alt=&quot;Markdowm Image&quot; /&gt;
  &lt;!-- ![Markdowm Image](/assets\VSlam\image_77.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_77.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;customname3_3&quot;&gt;3.3、直接法&lt;/h4&gt;

    &lt;p&gt;&lt;!-- ![Markdowm Image](/assets\VSlam\image_78.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_78.png&quot; alt=&quot;Markdowm Image&quot; /&gt;
  &lt;!-- ![Markdowm Image](/assets\VSlam\image_79.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_79.png&quot; alt=&quot;Markdowm Image&quot; /&gt;
  &lt;!-- ![Markdowm Image](/assets\VSlam\image_80.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_80.png&quot; alt=&quot;Markdowm Image&quot; /&gt;
  &lt;!-- ![Markdowm Image](/assets\VSlam\image_81.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_81.png&quot; alt=&quot;Markdowm Image&quot; /&gt;
  &lt;!-- ![Markdowm Image](/assets\VSlam\image_82.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_82.png&quot; alt=&quot;Markdowm Image&quot; /&gt;
  &lt;!-- ![Markdowm Image](/assets\VSlam\image_83.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_83.png&quot; alt=&quot;Markdowm Image&quot; /&gt;
  &lt;!-- ![Markdowm Image](/assets\VSlam\image_84.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_84.png&quot; alt=&quot;Markdowm Image&quot; /&gt;
  &lt;!-- ![Markdowm Image](/assets\VSlam\image_85.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_85.png&quot; alt=&quot;Markdowm Image&quot; /&gt;
  &lt;!-- ![Markdowm Image](/assets\VSlam\image_86.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_86.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;customname4&quot;&gt;4、后端/非线性优化(Optimization)&lt;/h3&gt;

&lt;!-- ![Markdowm Image](/assets\VSlam\image_87.png) --&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_87.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;customname4_1&quot;&gt;4.1、基于滤波器&lt;/h4&gt;

    &lt;p&gt;&lt;!-- ![Markdowm Image](/assets\VSlam\image_88.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_88.png&quot; alt=&quot;Markdowm Image&quot; /&gt;
  &lt;!-- ![Markdowm Image](/assets\VSlam\image_89.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_89.png&quot; alt=&quot;Markdowm Image&quot; /&gt;
  &lt;!-- ![Markdowm Image](/assets\VSlam\image_90.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_90.png&quot; alt=&quot;Markdowm Image&quot; /&gt;
  &lt;!-- ![Markdowm Image](/assets\VSlam\image_91.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_91.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;customname4_2&quot;&gt;4.2、基于非线性优化&lt;/h4&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;h5 id=&quot;ba&quot;&gt;BA&lt;/h5&gt;

        &lt;p&gt;&lt;!-- ![Markdowm Image](/assets\VSlam\image_92.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_92.png&quot; alt=&quot;Markdowm Image&quot; /&gt;
  &lt;!-- ![Markdowm Image](/assets\VSlam\image_93.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_93.png&quot; alt=&quot;Markdowm Image&quot; /&gt;
  &lt;!-- ![Markdowm Image](/assets\VSlam\image_94.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_94.png&quot; alt=&quot;Markdowm Image&quot; /&gt;
  &lt;!-- ![Markdowm Image](/assets\VSlam\image_95.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_95.png&quot; alt=&quot;Markdowm Image&quot; /&gt;
  &lt;!-- ![Markdowm Image](/assets\VSlam\image_96.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_96.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;h5 id=&quot;位姿图&quot;&gt;位姿图&lt;/h5&gt;

        &lt;p&gt;&lt;!-- ![Markdowm Image](/assets\VSlam\image_97.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_97.png&quot; alt=&quot;Markdowm Image&quot; /&gt;
  &lt;!-- ![Markdowm Image](/assets\VSlam\image_98.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_98.png&quot; alt=&quot;Markdowm Image&quot; /&gt;
  &lt;!-- ![Markdowm Image](/assets\VSlam\image_99.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_99.png&quot; alt=&quot;Markdowm Image&quot; /&gt;
  &lt;!-- ![Markdowm Image](/assets\VSlam\image_100.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_100.png&quot; alt=&quot;Markdowm Image&quot; /&gt;
  &lt;!-- ![Markdowm Image](/assets\VSlam\image_101.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_101.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;customname5&quot;&gt;5、回环检测(Loop Closing)&lt;/h3&gt;

&lt;!-- ![Markdowm Image](/assets\VSlam\image_102.png) --&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_102.png&quot; alt=&quot;Markdowm Image&quot; /&gt;
&lt;!-- ![Markdowm Image](/assets\VSlam\image_103.png) --&gt;
&lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_103.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;customname6&quot;&gt;6、建图&lt;/h3&gt;

&lt;!-- ![Markdowm Image](/assets\VSlam\image_104.png) --&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_104.png&quot; alt=&quot;Markdowm Image&quot; /&gt;
&lt;!-- ![Markdowm Image](/assets\VSlam\image_105.png) --&gt;
&lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_105.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;customname6_1&quot;&gt;6.1、单目稠密重建&lt;/h4&gt;

    &lt;p&gt;&lt;!-- ![Markdowm Image](/assets\VSlam\image_109.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_109.png&quot; alt=&quot;Markdowm Image&quot; /&gt;
  &lt;!-- ![Markdowm Image](/assets\VSlam\image_110.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_110.png&quot; alt=&quot;Markdowm Image&quot; /&gt;
  &lt;!-- ![Markdowm Image](/assets\VSlam\image_111.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_111.png&quot; alt=&quot;Markdowm Image&quot; /&gt;
  &lt;!-- ![Markdowm Image](/assets\VSlam\image_112.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_112.png&quot; alt=&quot;Markdowm Image&quot; /&gt;
  &lt;!-- ![Markdowm Image](/assets\VSlam\image_113.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_113.png&quot; alt=&quot;Markdowm Image&quot; /&gt;
  &lt;!-- ![Markdowm Image](/assets\VSlam\image_114.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_114.png&quot; alt=&quot;Markdowm Image&quot; /&gt;
  &lt;!-- ![Markdowm Image](/assets\VSlam\image_115.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_115.png&quot; alt=&quot;Markdowm Image&quot; /&gt;
  &lt;!-- ![Markdowm Image](/assets\VSlam\image_116.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_116.png&quot; alt=&quot;Markdowm Image&quot; /&gt;
  &lt;!-- ![Markdowm Image](/assets\VSlam\image_117.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_117.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;customname6_2&quot;&gt;6.2、RGB-D稠密建图&lt;/h4&gt;

    &lt;p&gt;&lt;!-- ![Markdowm Image](/assets\VSlam\image_106.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_106.png&quot; alt=&quot;Markdowm Image&quot; /&gt;
  &lt;!-- ![Markdowm Image](/assets\VSlam\image_107.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_107.png&quot; alt=&quot;Markdowm Image&quot; /&gt;
  &lt;!-- ![Markdowm Image](/assets\VSlam\image_108.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\VSlam\image_108.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;其他资料&quot;&gt;其他资料&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;视觉slam要点pdf&quot;&gt;视觉SLAM要点.pdf&lt;/h4&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;参考&quot;&gt;参考&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;视觉SLAM十四讲&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="blog" /><category term="SLAM" /><summary type="html">目录</summary></entry><entry><title type="html">C++</title><link href="http://localhost:4000/C++/" rel="alternate" type="text/html" title="C++" /><published>2022-12-26T23:38:00+08:00</published><updated>2022-12-26T23:38:00+08:00</updated><id>http://localhost:4000/C++</id><content type="html" xml:base="http://localhost:4000/C++/">&lt;h2 id=&quot;目录&quot;&gt;目录&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h3 id=&quot;1c基础&quot;&gt;&lt;a href=&quot;#customname1&quot;&gt;1、C++基础&lt;/a&gt;&lt;/h3&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;h4 id=&quot;11变量和基本类型&quot;&gt;&lt;a href=&quot;#customname1_1&quot;&gt;1.1、变量和基本类型&lt;/a&gt;&lt;/h4&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;h4 id=&quot;12字符串向量数组&quot;&gt;&lt;a href=&quot;#customname1_2&quot;&gt;1.2、字符串、向量、数组&lt;/a&gt;&lt;/h4&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;h4 id=&quot;13表达式&quot;&gt;&lt;a href=&quot;#customname1_3&quot;&gt;1.3、表达式&lt;/a&gt;&lt;/h4&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;h4 id=&quot;14语句&quot;&gt;&lt;a href=&quot;#customname1_4&quot;&gt;1.4、语句&lt;/a&gt;&lt;/h4&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;h4 id=&quot;15函数&quot;&gt;&lt;a href=&quot;#customname1_5&quot;&gt;1.5、函数&lt;/a&gt;&lt;/h4&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h3 id=&quot;2c标准库&quot;&gt;&lt;a href=&quot;#customname2&quot;&gt;2、C++标准库&lt;/a&gt;&lt;/h3&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;h4 id=&quot;21io库&quot;&gt;&lt;a href=&quot;#customname2_1&quot;&gt;2.1、IO库&lt;/a&gt;&lt;/h4&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;h4 id=&quot;22顺序容器&quot;&gt;&lt;a href=&quot;#customname2_2&quot;&gt;2.2、顺序容器&lt;/a&gt;&lt;/h4&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;h4 id=&quot;23关联容器&quot;&gt;&lt;a href=&quot;#customname2_3&quot;&gt;2.3、关联容器&lt;/a&gt;&lt;/h4&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;h4 id=&quot;24泛型算法&quot;&gt;&lt;a href=&quot;#customname2_4&quot;&gt;2.4、泛型算法&lt;/a&gt;&lt;/h4&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;h4 id=&quot;25动态内存&quot;&gt;&lt;a href=&quot;#customname2_5&quot;&gt;2.5、动态内存&lt;/a&gt;&lt;/h4&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h3 id=&quot;3c类&quot;&gt;&lt;a href=&quot;#customname3&quot;&gt;3、C++类&lt;/a&gt;&lt;/h3&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;h4 id=&quot;31类基础&quot;&gt;&lt;a href=&quot;#customname3_1&quot;&gt;3.1、类基础&lt;/a&gt;&lt;/h4&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;h4 id=&quot;32拷贝控制&quot;&gt;&lt;a href=&quot;#customname3_2&quot;&gt;3.2、拷贝控制&lt;/a&gt;&lt;/h4&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;h4 id=&quot;33运算符重载&quot;&gt;&lt;a href=&quot;#customname3_3&quot;&gt;3.3、运算符重载&lt;/a&gt;&lt;/h4&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;h4 id=&quot;34oop&quot;&gt;&lt;a href=&quot;#customname3_4&quot;&gt;3.4、OOP&lt;/a&gt;&lt;/h4&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;h4 id=&quot;35模板泛型编程&quot;&gt;&lt;a href=&quot;#customname3_5&quot;&gt;3.5、模板、泛型编程&lt;/a&gt;&lt;/h4&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h3 id=&quot;4c高级主题&quot;&gt;&lt;a href=&quot;#customname4&quot;&gt;4、C++高级主题&lt;/a&gt;&lt;/h3&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;h4 id=&quot;41标准库特殊设施&quot;&gt;&lt;a href=&quot;#customname4_1&quot;&gt;4.1、标准库特殊设施&lt;/a&gt;&lt;/h4&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;h4 id=&quot;42用于大型程序的工具&quot;&gt;&lt;a href=&quot;#customname4_2&quot;&gt;4.2、用于大型程序的工具&lt;/a&gt;&lt;/h4&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;h4 id=&quot;43特殊工具与技术&quot;&gt;&lt;a href=&quot;#customname4_3&quot;&gt;4.3、特殊工具与技术&lt;/a&gt;&lt;/h4&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;h4 id=&quot;44c11&quot;&gt;&lt;a href=&quot;#customname4_4&quot;&gt;4.4、C++11&lt;/a&gt;&lt;/h4&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;customname1&quot;&gt;1、C++基础&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;customname1_1&quot;&gt;1.1、变量和基本类型&lt;/h4&gt;

    &lt;p&gt;&lt;!-- ![Markdowm Image](/assets\C++\image_1.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\C++\image_1.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;自动存储持续性？&lt;/strong&gt;
  对应的变量称为局部变量，存储在栈中，生命周期为作用域的生命周期。能隐藏同名的全局变量。&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;静态存储持续性？&lt;/strong&gt;
  对应的变量称为静态变量或全局变量，存储在固定的内存块中，生命周期为整个程序的生命周期。
  &lt;strong&gt;外部链接性、内部链接性、无链接性的区别？&lt;/strong&gt;&lt;br /&gt;
  在文件中代码块外部声明的变量具有外部链接性，可被其他文件访问。extern 关键字用于声明引用一个其他文件中的外部链接性的变量。在文件中代码块外声明并且加了static 的变量具有内部链接性，只能在当前文件访问，不能被其他文件访问。在代码块内声明并且加了static的变量是无链接性，只能在对应的代码块内访问。&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;动态存储持续性？&lt;/strong&gt;
  对应的变量称为动态变量，存在在堆中，生命周期直到delete 释放为止。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;顶层const 和底层const&lt;/strong&gt;
  顶层const 表示本身是一个常量，底层const 表示指向的对象是一个常量。&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;default 和delete 关键字&lt;/strong&gt;
  default 关键字用于自定义的构造函数（6 种），将命令编译器创建对应的默认版本。delete 关键字可以用于任何一个成员函数，让编译器不使用这个函数。&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;override 和final 关键字&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;override 关键字加在派生类的虚函数后，显式的表明需要去重写基类同名同特征标的虚函数，如果基类没有就报错。&lt;/li&gt;
          &lt;li&gt;final 关键字加在虚函数后，显式指出之后的派生类不能重写这个虚函数。否则报错。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;函数指针、函数符、lambda 表达式&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;函数指针是指向函数的指针，声明函数时将函数名换为 &lt;strong&gt;*指针名&lt;/strong&gt;即可。&lt;/li&gt;
          &lt;li&gt;函数符是可以以函数方式与（）结合使用的任意对象，包括函数名、指向函数的指针和重载了（）运算符的类对象。&lt;/li&gt;
          &lt;li&gt;Lambda 表达式表示一个可调用的代码单元，可以理解为一个匿名的内联函数。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;内联函数&lt;/strong&gt;
  使用inline 关键字，声明的同时提供定义。在编译过程中，编译器直接将函数调用替换成函数代码，执行时就不需要反复跳转，运行速度快于常规函数，但需要更多的内存。内联函数不能递归。&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;Lambda 表达式：&lt;/strong&gt;
  C++引入lambda 表达式的主要目的是参数为函数指针或者函数符的的函数也可以接受类似于函数的表达式作为参数。&lt;strong&gt;一种常见的用法是作为参数传递给STL 函数。&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;Lambda 表达式显式捕获和隐式捕获&lt;/strong&gt;
  显式捕获指在[]中显示的指明需要捕获表达式所在作用域内的某个变量，分为值捕获和引用捕获。隐式捕获在[]中使用=或者&amp;amp;，表明lambda 表达式可以按值或按引用使用作用域内的所有变量。可以混合使用隐式捕获和显式捕获，显式指出的变量按照其对应的方式捕获，其余的变量按照指定的方式隐式捕获。混合使用时，方括号第一个参数必须是隐式捕获。&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;C++中的强制类型转换：&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;static_cast：将表达式类型强制转换为目标类型（只有在两者之间可以隐式转换时才能用）。不能去掉表达式的const。&lt;/li&gt;
          &lt;li&gt;const_cast：将const 类型强制换行为非const 类型。&lt;/li&gt;
          &lt;li&gt;reinterpret_cast：是一种比特位的重新解释，强制转换得到一个新的值，该值与原始表达式有完全相同的比特位。&lt;/li&gt;
          &lt;li&gt;dynamic_cast：主要作用是将基类的指针或引用安全的转换成派生类的指针或引用（向下强制转换）。当然可以用于向上转换和同类型的转换，虽然隐式也可以完成这种转换。对于指针：可以安全转换就返回转换后的地址，不能就返回nullptr。对于引用：可以安全转换就返回转换后的引用，不能就引发bad_cast 异常。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;RTTI：&lt;/strong&gt;
  运行阶段类型识别，用于程序在运行阶段确定对象的类型（如判断基类的指针到底指向了哪种对象）。C++有三种支持RTTI 的元素：dynamic_cast、typeid、type_info。typeid 运算符返回一个指出对象类型的值（type_Info 的引用），type_info 结构存储了有关特定类型的信息。&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;纯虚函数和虚函数的区别&lt;/strong&gt;
  含有纯虚函数的类自定义接口，不提供实现，不能创建对象。含有虚函数的类可以。虚函数可以被直接使用，纯虚函数需要在派生类中定义后才能使用&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;static 关键字：&lt;/strong&gt;
  在局部作用域内声明的static 变量，内存只被分配一次，下次进入作用域时仍然维持上一次的值。&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;const 关键字：&lt;/strong&gt;
  阻止一个变量被改变、顶层const、底层const、const 形参、const 函数、const 返回值。&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;可变参数模板&lt;/strong&gt;
  class …T：声明一个模板参数包T；T …args：声明一个T 类型的函数参数包args。C++11 使用递归的方式展开参数包。&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;转发&lt;/strong&gt;
  在函数模板中依照参数的类型，将参数传递给模板中调用的另一个函数，通常按照引用传递来提高效率。模板参数可能也是引用类型，因此为了兼容所有左值、右值、左值引用、右值引用作为模板参数，C++11 采用了引用折叠，比如模板参数实例化为右值引用，模板中使用了模板参数的右值引用，那么右值引用的右值引用将被折叠为右值引用。可以使用forword 函数完成左值引用到右值引用的转换。&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;迭代器&lt;/strong&gt;
  指针可以用来遍历存储空间连续的数据结构，但是对于存储空间不连续的，就需要寻找一个行为类似指针的类，来对非数组的数据结构进行遍历。并且方便STL 算法对容器的访问，因此C++引入迭代器。
        &lt;ul&gt;
          &lt;li&gt;迭代器提供了对一个容器中对象的访问方法，并且定义了容器中对象的范围。&lt;/li&gt;
          &lt;li&gt;STL 有5 种迭代器：输入迭代器、输出迭代器、正向迭代器、双向迭代器、随机访问迭代器。&lt;/li&gt;
          &lt;li&gt;输入迭代器只能读容器信息，不能写容器信息。&lt;/li&gt;
          &lt;li&gt;输出迭代器可以解引用让程序修改容器值，但不能读取。&lt;/li&gt;
          &lt;li&gt;正向迭代器只能++，可读取和修改数据。&lt;/li&gt;
          &lt;li&gt;双向迭代器可++可–，可读取和修改数据。&lt;/li&gt;
          &lt;li&gt;随机访问迭代器具有双向迭代器的所有特性，还支持随机访问和使用关系运算符比较指向的值。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;customname1_2&quot;&gt;1.2、字符串、向量、数组&lt;/h4&gt;

    &lt;p&gt;&lt;!-- ![Markdowm Image](/assets\C++\image_2.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\C++\image_2.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;customname1_3&quot;&gt;1.3、表达式&lt;/h4&gt;

    &lt;p&gt;&lt;!-- ![Markdowm Image](/assets\C++\image_3.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\C++\image_3.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;customname1_4&quot;&gt;1.4、语句&lt;/h4&gt;

    &lt;p&gt;&lt;!-- ![Markdowm Image](/assets\C++\image_4.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\C++\image_4.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;customname1_5&quot;&gt;1.5、函数&lt;/h4&gt;

    &lt;p&gt;&lt;!-- ![Markdowm Image](/assets\C++\image_5.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\C++\image_5.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;如何实现函数重载？&lt;/strong&gt;
  函数名相同而特征标不同；特征标相同：参数数目相同&amp;amp;&amp;amp; 参数类型相同&amp;amp;&amp;amp; 参数的排列顺序相同。类型引用和类型本身视为同一个特征标&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;显示具体化、隐式实例化、显示实例化的区别？&lt;/strong&gt;
  实例化不需要提供新的模板定义，只是根据具体的类型，用原来的模板定义创建实例。具体化需要根据具体的类型创建新的定义。隐式实例化是根据调用的参数自动推断模板类型，然后根据模板生成对应的函数定义，显示实例化是命令编译器为某种类型创建函数定义，以提高编译和链接的效率。显示具体化是针对某种类型，源模板定义不能实现某些功能，所以人为提供定义来实现。&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;decltype 关键字作用？&lt;/strong&gt;
  用于推断表达式的类型，auto 占位返回类型，然后使用decltype 可实现模板函数后置返回类型&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;customname2&quot;&gt;2、C++标准库&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;customname2_1&quot;&gt;2.1、IO库&lt;/h4&gt;

    &lt;p&gt;&lt;!-- ![Markdowm Image](/assets\C++\image_6.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\C++\image_6.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;&lt;!-- ![Markdowm Image](/assets\C++\image_6_1.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\C++\image_6_1.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;customname2_2&quot;&gt;2.2、顺序容器&lt;/h4&gt;

    &lt;p&gt;&lt;!-- ![Markdowm Image](/assets\C++\image_7.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\C++\image_7.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;vector 是如何增长的&lt;/strong&gt;
  为了支持快速随机访问，vector 将元素连续存储。每次重新分配内存，需要移动现存的所有元素，为了减少移动的次数，通常会分配比新的空间需求更大的内存空间，以减少移动的频率。resize 改变容器中元素的数目，reserve 调整容器的容量。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;customname2_3&quot;&gt;2.3、关联容器&lt;/h4&gt;

    &lt;p&gt;&lt;!-- ![Markdowm Image](/assets\C++\image_8.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\C++\image_8.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;map 和 unordered_map 的区别？&lt;/strong&gt;
  键值都必须唯一。map 底层是基于红黑树实现的，map 会按键值自动排序，因此 map 中元素的排列都是有序的，插入和查询时间复杂度是对数级的。unordered_map 底层是基于哈希表实现的，插入和查询时间复杂度是常数级的，但是元素是无序的。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;customname2_4&quot;&gt;2.4、泛型算法&lt;/h4&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;customname2_5&quot;&gt;2.5、动态内存&lt;/h4&gt;

    &lt;p&gt;&lt;!-- ![Markdowm Image](/assets\C++\image_9.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\C++\image_9.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;customname3&quot;&gt;3、C++类&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;customname3_1&quot;&gt;3.1、类基础&lt;/h4&gt;

    &lt;p&gt;&lt;!-- ![Markdowm Image](/assets\C++\image_10.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\C++\image_10.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;const 成员变量、static 成员变量、static const 成员常量的区别？&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;const 成员变量声明后不能被修改，只能在构造函数中使用成员初始化列表语法来初始化。&lt;/li&gt;
          &lt;li&gt;static 成员变量定义静态成员变量，被所有对象共享且只有一个，不能在类声明中初始化，因为还没有分配内存，在声明之后使用单独的语句来初始化&lt;/li&gt;
          &lt;li&gt;static const 用于声明静态成员常量，被所有对象共享且只有一个，不能被更改，可以在类声明中初始化。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;const 成员函数、static 成员函数的区别？&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;const 成员函数内无法修改数据成员，且不能调用非const 成员函数。&lt;/li&gt;
          &lt;li&gt;static 成员函数独立于对象，不能通过对象调用，只能通过类来调用，函数中只能使用静态成员。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;友元的作用？&lt;/strong&gt;
  除了公有成员函数外另外一种访问类私有成员的方法，友元不是成员函数。&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;隐式类型转换和显示类型转换？&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;如果定义了只接受一个参数的构造函数，那么将可以进行参数类型到类类型的隐式类型转换（赋值、返回、传参）。对这种构造函数使用explicit 关键字，将禁止隐式的类型转换，只能显式转换。&lt;/li&gt;
          &lt;li&gt;如果要将类对象转换为其他类型，需要使用operator 定义转换函数。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;为什么派生类的构造函数要使用成员初始化列表语法来调用基类的构造函数？&lt;/strong&gt;
  因为在构造派生类对象时，要先构造派生类对象的基类部分，就需要先调用基类构造函数，但是在进入派生类构造函数之后，派生类就已经被构造，所以需要用成员初始化列表语法调用基类的构造函数，如果没有显示调用，将使用默认的基类构造函数。&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;基类指针或者引用指向派生类对象，派生类指针或引用指向基类对象？&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;基类指针和引用可以不显示转换的情况下指向派生类对象，因为从逻辑上说派生类对象也是基类对象，然而只能访问派生类的基类部分。&lt;/li&gt;
          &lt;li&gt;派生类指针或引用不能指向基类对象，除非基类对象强制转换为派生类对象。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;如何进行深拷贝？&lt;/strong&gt;
  默认的复制构造函数和复制赋值运算符执行浅拷贝，要执行深拷贝需要自定义复制构造函数和复制赋值运算符来实现。
        &lt;ul&gt;
          &lt;li&gt;如果基类使用了new，派生类没有使用new，派生类不需要自定义复制构造和复制赋值，默认的版本会自动调用基类自定义的版本（因为自定义了，编译器不会生成默认了）。&lt;/li&gt;
          &lt;li&gt;如果基类使用了new，派生类也使用了new，派生类就需要自定义复制构造函数和复制赋值运算符来深拷贝派生类新定义的成员，基类的由基类函数深拷贝。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;为什么在派生类中不能调用基类的析构函数和赋值运算符（感觉没有被继承）？&lt;/strong&gt;
  实际上是被派生类的析构函数和赋值运算符隐藏了，要在派生类中调用需要使用作用域解析来调用。&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;基类对象和派生类对象之间的转换？&lt;/strong&gt;
  派生类对象可以隐式的转换为基类对象，只获得派生类的基类部分。基类对象转换为派生类对象需要显示转换。&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;基类指针或引用和派生类指针或引用之间的转换？&lt;/strong&gt;
  派生类指针或引用可以隐式转换为基类指针或引用，只能使用派生类的基类部分。基类指针或引用只有在显示转换时才能转换为派生类指针或引用。&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;什么是抽象基类？&lt;/strong&gt;
  包含纯虚函数的类是抽象基类，只定义接口，不能创建对象。&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;公有继承、保护继承、私有继承？&lt;/strong&gt;
  公有继承实现的是is-a 关系，保护继承和私有继承实现的是has-a 关系。三种继承方式基类的私有部分都只能通过基类的接口来访问，可以理解为变为派生类的私有部分。公有继承公有变公有，保护变保护。保护继承公有和保护都变保护。私有继承公有和保护都变私有。&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;什么是多态？&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;同一个方法在基类和派生类中表现出不同的行为。&lt;/li&gt;
          &lt;li&gt;实现多态的两个条件：&lt;strong&gt;使用虚方法&lt;/strong&gt;、&lt;strong&gt;派生类中重写基类的虚方法&lt;/strong&gt;。当通过基类指针或者引用调用一个被派生类重写的虚方法时，会根据指针或者引用指向的对象类型来调用对应方法。如果重写的不是虚方法，那么将根据指针或引用本身的类型来调用。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;多态是如何实现的？&lt;/strong&gt;
  多态是通过虚函数表来实现的，当某个类定义了虚函数时，编译器会为这个类定义一个虚函数表，这个类的每个对象都将多一个指针，指向虚函数表，虚函数表中存储当前类所有的虚函数名及其对应的地址。调用函数时会在虚函数表中查找函数地址，然后去执行。派生时，派生类也将定义一个虚函数表，如果派生类没有重写基类的虚函数，那么表中的虚函数的地址就是基类的地址，如果派生类重写了某个虚函数，那么表中的这个虚函数对应的地址将变为派生类重写的这个函数的地址。当通过基类指针或者引用调用一个被派生类重写的虚方法时，去指针或引用指向的类型的虚函数表中找到函数的地址去执行。&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;为什么构造函数不能是虚函数？&lt;/strong&gt;
  因为要构造某个类型的对象，一定是调用这个类型的构造函数，而不是动态的选择其他的函数来构造这个函数，所以不需要多态特性，也就不需要设为虚函数。&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;为什么析构函数要是虚函数？&lt;/strong&gt;
  如果一个类作为基类，那么析构函数要是虚函数，这样基类的指针或引用指向派生类对象时，释放对象才能先调用派生类的析构函数，然后调用基类的析构函数，正确的回收内存。&lt;/li&gt;
      &lt;li&gt;派生类中重写的基类虚方法会覆盖基类中所有同名的虚方法，即使特征标不同（在虚函数表中表现为，所有同名的虚方法地址被设为派生类重写的这个虚方法）。为避免覆盖，应该在派生类中顺便重写其他同名的版本。&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;什么是动态联编和静态联编？&lt;/strong&gt;
  编译器为函数调用找到对应的地址的过程称为联编，对于非虚方法采用静态联编，在编译过程中确定对应的地址。对于虚方法采用动态联编，在运行过程中决定去哪个虚函数表中查找地址。&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;派生类访问基类私有成员？&lt;/strong&gt;
  使用基类的接口、使用using 重新定义访问权限、强制类型转换为基类&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;多重继承中为什么要使用虚基类？&lt;/strong&gt;
  如果多个基类都是从相同的祖先基类派生得到，那么派生类将会有多个祖先基类部分，这会使得使用多态特性时变得复杂，虚基类技术使得相同的祖先基类只有一个。通过基类从祖先基类派生时加virtual 关键字来实现。&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;类模板的隐式实例化、显式实例化、显式具体化、部分具体化区别？&lt;/strong&gt;
  隐式实例化、显式实例化、显式具体化和函数模板相同，部分具体化可以给类型参数之一指定具体的类型，并且要提供相应的定义。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;customname3_2&quot;&gt;3.2、拷贝控制&lt;/h4&gt;

    &lt;p&gt;&lt;!-- ![Markdowm Image](/assets\C++\image_11.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\C++\image_11.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;customname3_3&quot;&gt;3.3、运算符重载&lt;/h4&gt;

    &lt;p&gt;&lt;!-- ![Markdowm Image](/assets\C++\image_12.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\C++\image_12.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;customname3_4&quot;&gt;3.4、OOP&lt;/h4&gt;

    &lt;p&gt;&lt;!-- ![Markdowm Image](/assets\C++\image_13.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\C++\image_13.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;customname3_5&quot;&gt;3.5、模板、泛型编程&lt;/h4&gt;

    &lt;p&gt;&lt;!-- ![Markdowm Image](/assets\C++\image_14.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\C++\image_14.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;customname4&quot;&gt;4、C++高级主题&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;customname4_1&quot;&gt;4.1、标准库特殊设施&lt;/h4&gt;

    &lt;p&gt;&lt;!-- ![Markdowm Image](/assets\C++\image_15.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\C++\image_15.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;customname4_2&quot;&gt;4.2、用于大型程序的工具&lt;/h4&gt;

    &lt;p&gt;&lt;!-- ![Markdowm Image](/assets\C++\image_16.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\C++\image_16.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;customname4_3&quot;&gt;4.3、特殊工具与技术&lt;/h4&gt;

    &lt;p&gt;&lt;!-- ![Markdowm Image](/assets\C++\image_17.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\C++\image_17.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;44c11customname4_4&quot;&gt;4.4、C++11{#customname4_4}&lt;/h4&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;h5 id=&quot;智能指针&quot;&gt;智能指针&lt;/h5&gt;

        &lt;p&gt;&lt;!-- ![Markdowm Image](/assets\C++\image_18.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\C++\image_18.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

        &lt;p&gt;智能指针的作用是负责自动释放所指向的对象，三种智能指针，shared_ptr、unique_ptr、weak_ptr。&lt;/p&gt;
        &lt;ul&gt;
          &lt;li&gt;shared_ptr 是共享型，允许多个指针指向同一个对象，使用引用计数来记录当前有多少个指针指向同一个对象，在有新指针指向对象时，引用计数加1，但一个指针被销毁时，引用计数减1，当引用计数减到0 时，表示没有指针再指向对象，可以将对象释放。&lt;/li&gt;
          &lt;li&gt;unique_ptr是独占型，同一时刻独占指向的对象，指针被销毁时，指向的对象自动被释放，不支持普通的拷贝和赋值操作，需要调用.release()放弃控制权。调用.reset(q)释放当前对象，并指向新对象q。&lt;/li&gt;
          &lt;li&gt;weak_ptr 是一种指向shared_ptr 指向的对象的弱引用，不影响引用计数，weak_ptr 不能直接访问对象，需要先使用.lock()函数检查指向的对象是否存在。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;h5 id=&quot;移动语义和右值引用&quot;&gt;移动语义和右值引用&lt;/h5&gt;

        &lt;p&gt;&lt;!-- ![Markdowm Image](/assets\C++\image_19.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\C++\image_19.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;&lt;strong&gt;移动语义&lt;/strong&gt;
  避免移动内存中的数据，只是修改记录，如果谁接管。通过移动构造函数和移动赋值运算符实现，两者的形参都应为右值引用，实参都为右值。&lt;/li&gt;
          &lt;li&gt;&lt;strong&gt;右值引用&lt;/strong&gt;
  左值和右值的区别在于是否能获取地址。将右值关联到右值引用导致右值被存储到特定的位置，有了地址。左值引用能更改指向对象，因此左值引用可以指向左值、右值引用，但是不能指向右值。const 左值引用不能改变指向对象，除了可以指向左值、右值引用，也就可以指向右值。右值引用只能指向临时对象。std：：move 函数将左值转换为右值并初始化一个右值引用。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;h5 id=&quot;类构造函数&quot;&gt;类构造函数&lt;/h5&gt;

        &lt;p&gt;&lt;!-- ![Markdowm Image](/assets\C++\image_20.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets\C++\image_20.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;&lt;strong&gt;移动构造函数和移动赋值运算符&lt;/strong&gt;
  用于实现移动语义，移动构造函数（移动赋值运算符）不会分配任何新内存，它接管源对象的内存。在移动构造函数（移动赋值运算符）中接管后，应该手动将源对象中指向这个内存的指针置为nullptr。默认移动构造函数（移动赋值运算符）不会设置，是危险的&lt;/li&gt;
          &lt;li&gt;&lt;strong&gt;复制构造函数和复制赋值运算符&lt;/strong&gt;
  形参为 const 左值引用。因为 const 左值引用可以指向右值，因此没有移动构造函数和移动赋值运算符时，将调用复制构造函数和复制赋值运算符。只要自定义了复制构造函数和复制赋值运算符（移动构造函数和移动赋值运算符），编译器就不会再提供复制和移动的这 4 种默认函数。&lt;/li&gt;
          &lt;li&gt;&lt;strong&gt;委托构造函数和继承构造函数&lt;/strong&gt;
  在一个构造函数中调用另一个构造函数，称为委托。派生类中可以通过显式声明的形式继承基类自定义的构造函数。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;h5 id=&quot;lambda表达式&quot;&gt;lambda表达式&lt;/h5&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;h5 id=&quot;包装器&quot;&gt;包装器&lt;/h5&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;h5 id=&quot;stdinitializer_list&quot;&gt;std::initializer_list&lt;/h5&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;h5 id=&quot;可变参数模板&quot;&gt;可变参数模板&lt;/h5&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;5其他资料&quot;&gt;5、其他资料&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;c重点xmind&quot;&gt;C++重点.xmind&lt;/h4&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;c要点pdf&quot;&gt;C++要点.pdf&lt;/h4&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="blog" /><category term="C++" /><summary type="html">目录</summary></entry><entry><title type="html">数据结构和算法</title><link href="http://localhost:4000/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/" rel="alternate" type="text/html" title="数据结构和算法" /><published>2022-12-25T23:38:00+08:00</published><updated>2022-12-25T23:38:00+08:00</updated><id>http://localhost:4000/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95</id><content type="html" xml:base="http://localhost:4000/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/">&lt;h2 id=&quot;目录&quot;&gt;目录&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h3 id=&quot;1线性结构&quot;&gt;&lt;a href=&quot;#customname1&quot;&gt;1、线性结构&lt;/a&gt;&lt;/h3&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;h4 id=&quot;11链表&quot;&gt;&lt;a href=&quot;#customname1_1&quot;&gt;1.1、链表&lt;/a&gt;&lt;/h4&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;h4 id=&quot;12栈&quot;&gt;&lt;a href=&quot;#customname1_2&quot;&gt;1.2、栈&lt;/a&gt;&lt;/h4&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;h4 id=&quot;13队列&quot;&gt;&lt;a href=&quot;#customname1_3&quot;&gt;1.3、队列&lt;/a&gt;&lt;/h4&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;h4 id=&quot;14字符串&quot;&gt;&lt;a href=&quot;#customname1_4&quot;&gt;1.4、字符串&lt;/a&gt;&lt;/h4&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;h4 id=&quot;15数组&quot;&gt;&lt;a href=&quot;#customname1_5&quot;&gt;1.5、数组&lt;/a&gt;&lt;/h4&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h3 id=&quot;2树型结构&quot;&gt;&lt;a href=&quot;#customname2&quot;&gt;2、树型结构&lt;/a&gt;&lt;/h3&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;h4 id=&quot;21二叉树&quot;&gt;&lt;a href=&quot;#customname2_1&quot;&gt;2.1、二叉树&lt;/a&gt;&lt;/h4&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;h4 id=&quot;22多叉树&quot;&gt;&lt;a href=&quot;#customname2_2&quot;&gt;2.2、多叉树&lt;/a&gt;&lt;/h4&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h3 id=&quot;3图型结构&quot;&gt;&lt;a href=&quot;#customname3&quot;&gt;3、图型结构&lt;/a&gt;&lt;/h3&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h3 id=&quot;4算法&quot;&gt;&lt;a href=&quot;#customname4&quot;&gt;4、算法&lt;/a&gt;&lt;/h3&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;h4 id=&quot;41排序&quot;&gt;&lt;a href=&quot;#customname1_1&quot;&gt;4.1、排序&lt;/a&gt;&lt;/h4&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;h4 id=&quot;42查找&quot;&gt;&lt;a href=&quot;#customname1_2&quot;&gt;4.2、查找&lt;/a&gt;&lt;/h4&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;h4 id=&quot;43索引&quot;&gt;&lt;a href=&quot;#customname1_3&quot;&gt;4.3、索引&lt;/a&gt;&lt;/h4&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;h4 id=&quot;44分治&quot;&gt;&lt;a href=&quot;#customname1_4&quot;&gt;4.4、分治&lt;/a&gt;&lt;/h4&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;h4 id=&quot;45回溯&quot;&gt;&lt;a href=&quot;#customname1_5&quot;&gt;4.5、回溯&lt;/a&gt;&lt;/h4&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;h4 id=&quot;46贪心&quot;&gt;&lt;a href=&quot;#customname1_6&quot;&gt;4.6、贪心&lt;/a&gt;&lt;/h4&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;h4 id=&quot;47动态规划&quot;&gt;&lt;a href=&quot;#customname1_7&quot;&gt;4.7、动态规划&lt;/a&gt;&lt;/h4&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;customname1&quot;&gt;1、线性结构&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;customname1_1&quot;&gt;1.1、链表&lt;/h4&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;单向链表、双向链表、循环链表&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;a href=&quot;https://github.com/yang-yang-o-o/Data-Structures-and-Algorithms/blob/a42fae1296568edcd9b66b953def69c31bdae391/SList.cpp#L72&quot;&gt;C++实现&lt;/a&gt;&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;customname1_2&quot;&gt;1.2、栈&lt;/h4&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;customname1_3&quot;&gt;1.3、队列&lt;/h4&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;customname1_4&quot;&gt;1.4、字符串&lt;/h4&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://github.com/yang-yang-o-o/Data-Structures-and-Algorithms/blob/a42fae1296568edcd9b66b953def69c31bdae391/KMP.cpp#L22&quot;&gt;KMP算法C++实现&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;customname1_5&quot;&gt;1.5、数组&lt;/h4&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;customname2&quot;&gt;2、树型结构&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;customname2_1&quot;&gt;2.1、二叉树&lt;/h4&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;一般二叉树&lt;/strong&gt;&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;
            &lt;p&gt;特点：子树互不相交、每个节点只有一个父节点&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;斜二叉树：每个父节点都只有一个子节点&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;完美二叉树（满二叉树）：每一个父节点都有两个子节点&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;完全二叉树：完美二叉树的最后一层叶节点从右到左连续的删除一部分，剩下的是完全二叉树。&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;二叉树的遍历：先序、中序、后序、层序&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;只需要知道先、中、后三种遍历顺序中的两种就能唯一确定一棵树，这两种必须包含中序遍历。&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;二叉树的实现：顺序存储实现、链式存储实现&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;&lt;a href=&quot;https://github.com/yang-yang-o-o/Data-Structures-and-Algorithms/blob/a42fae1296568edcd9b66b953def69c31bdae391/Binary_Tree/BinaryTree.h#L51&quot;&gt;C++实现&lt;/a&gt;&lt;/p&gt;

            &lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;  template&amp;lt;class T&amp;gt;
  class binaryTreeNode
  {   
  public:
                
      T element;
      binaryTreeNode&amp;lt;T&amp;gt; *leftChild,*rightChild;
                
      binaryTreeNode(){leftChild=rightChild=nullptr;}
      binaryTreeNode(const T&amp;amp; theElement):element(theElement),leftChild(nullptr),rightChild(nullptr),Height(0){}
      binaryTreeNode(const T&amp;amp; theElement,binaryTreeNode&amp;lt;T&amp;gt; * theLeftChild,binaryTreeNode&amp;lt;T&amp;gt; *theRightChild)
      {
          element = theElement;
          leftChild = theLeftChild;
          rightChild = theRightChild;
      }
      // AVLNode
      int Height;
      binaryTreeNode(const T&amp;amp; theElement,binaryTreeNode&amp;lt;T&amp;gt; * theLeftChild,binaryTreeNode&amp;lt;T&amp;gt; *theRightChild,int H)
      {
          element = theElement;
          leftChild = theLeftChild;
          rightChild = theRightChild;
          Height = H;
      }
  };  

  template&amp;lt;class E&amp;gt;
  // class linkedBinaryTree : public binaryTree&amp;lt;binaryTreeNode&amp;lt;E&amp;gt;&amp;gt;
  class linkedBinaryTree 
  {
  private:
      binaryTreeNode&amp;lt;E&amp;gt; *root;
      int treeSize;
      void (linkedBinaryTree&amp;lt;E&amp;gt;::*visit)(binaryTreeNode&amp;lt;E&amp;gt;*t);   // 这里如果声明为static，出的错误还未解决，还不会使用静态泛型函数指针
      void preOrder(binaryTreeNode&amp;lt;E&amp;gt; *t);
      void inOrder(binaryTreeNode&amp;lt;E&amp;gt; *t);
      void postOrder(binaryTreeNode&amp;lt;E&amp;gt; *t);
      void levelOrder(binaryTreeNode&amp;lt;E&amp;gt; *t);
      void levelOrder_DFS(binaryTreeNode&amp;lt;E&amp;gt; *t,int level,vector&amp;lt;vector&amp;lt;E&amp;gt;&amp;gt;&amp;amp; res);
      void dispose(binaryTreeNode&amp;lt;E&amp;gt; *t1){delete t1;t1 = nullptr;}   //不是new出来的不能用delete。因为在postOrder函数中递归传递指针t，如果这里使用同名指针会影响递归（可能是影响了上一层递归的t），即出错
      void output(binaryTreeNode&amp;lt;E&amp;gt;*t){cout&amp;lt;&amp;lt;t-&amp;gt;element&amp;lt;&amp;lt;&apos; &apos;;}
      void LeavesOutput(binaryTreeNode&amp;lt;E&amp;gt;*t);//打印叶节点
      int height(binaryTreeNode&amp;lt;E&amp;gt; *t); 
                
  public:
      linkedBinaryTree(){root=nullptr;treeSize=0;}
      linkedBinaryTree(const linkedBinaryTree&amp;lt;E&amp;gt; &amp;amp;t);             //复制构造函数
      linkedBinaryTree(binaryTreeNode&amp;lt;E&amp;gt;* t,int s){root=t;treeSize=s;}
      ~linkedBinaryTree(){}
                
      binaryTreeNode&amp;lt;E&amp;gt; *&amp;amp; getroot(){return root;}
                
      // void tese(binaryTreeNode&amp;lt;E&amp;gt;*t){visit=output;(this-&amp;gt;*visit)(t);}
      string empty()const {return treeSize==0?&quot;true&quot;:&quot;false&quot;;}
      int size()const {return treeSize;}
      void erase(){postOrder(dispose);root = nullptr;treeSize = 0;}
      void FreeNode(binaryTreeNode&amp;lt;E&amp;gt; *t){delete t;t=nullptr;}

      void preOrder(void(linkedBinaryTree&amp;lt;E&amp;gt;::*theVisit)(binaryTreeNode&amp;lt;E&amp;gt;*))
          {visit = theVisit;preOrder(root);}
      void inOrder(void(linkedBinaryTree&amp;lt;E&amp;gt;::*theVisit)(binaryTreeNode&amp;lt;E&amp;gt;*))
          {visit = theVisit;inOrder(root);}
      void postOrder(void(linkedBinaryTree&amp;lt;E&amp;gt;::*theVisit)(binaryTreeNode&amp;lt;E&amp;gt;*))
          {visit = theVisit;postOrder(root);}
      void levelOrder(void(linkedBinaryTree&amp;lt;E&amp;gt;::*theVisit)(binaryTreeNode&amp;lt;E&amp;gt;*))
          {visit = theVisit;levelOrder(root);}

      void inOrder_non_recursion();  // 非递归中序遍历
      void preOrder_non_recursion();  // 非递归先序遍历
      void postOrder_non_recursion();  // 非递归后序遍历
      vector&amp;lt;vector&amp;lt;E&amp;gt;&amp;gt; levelOrder_recursion();  // 递归层序遍历
      void preOrderOutput(){preOrder(output);cout&amp;lt;&amp;lt;endl;} 
      void inOrderOutput(){inOrder(output);cout&amp;lt;&amp;lt;endl;}
      void postOrderOutput(){postOrder(output);cout&amp;lt;&amp;lt;endl;}
      void levelOrderOutput(){levelOrder(output);cout&amp;lt;&amp;lt;endl;}  
      void PrintLeaves(){LeavesOutput(root);cout&amp;lt;&amp;lt;endl;};
      int height(){return height(root);}

      binaryTreeNode&amp;lt;E&amp;gt; * CopyTree(const binaryTreeNode&amp;lt;E&amp;gt; *t);
  };
&lt;/code&gt;&lt;/pre&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;二叉搜索树&lt;/strong&gt;&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;定义：
            &lt;ul&gt;
              &lt;li&gt;是二叉树，可为空或不为空&lt;/li&gt;
              &lt;li&gt;非空左子树的所有键值小于其根结点的键值&lt;/li&gt;
              &lt;li&gt;非空右子树的所有键值大于其根结点的键值&lt;/li&gt;
              &lt;li&gt;左、右子树都是二叉搜索树&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;功能函数
            &lt;ul&gt;
              &lt;li&gt;查找某个元素&lt;/li&gt;
              &lt;li&gt;返回最小元素&lt;/li&gt;
              &lt;li&gt;返回最大元素&lt;/li&gt;
              &lt;li&gt;插入一个元素&lt;/li&gt;
              &lt;li&gt;删除一个元素&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;性质
            &lt;ul&gt;
              &lt;li&gt;二叉搜索树的中序遍历是升序序列（在有相同值时是非递减的）&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;&lt;a href=&quot;https://github.com/yang-yang-o-o/Data-Structures-and-Algorithms/blob/a42fae1296568edcd9b66b953def69c31bdae391/Binary_Tree/Binary_Search_Tree.h#L8&quot;&gt;C++实现&lt;/a&gt;&lt;/p&gt;

            &lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;  template&amp;lt;class S&amp;gt;
  class BinarySearchTree : public linkedBinaryTree&amp;lt;S&amp;gt;
  {
  private:
      binaryTreeNode&amp;lt;S&amp;gt; * Find_private(S,binaryTreeNode&amp;lt;S&amp;gt;*);
      binaryTreeNode&amp;lt;S&amp;gt; * IterFind_private(S,binaryTreeNode&amp;lt;S&amp;gt;*);
      binaryTreeNode&amp;lt;S&amp;gt; * FindMin_private(binaryTreeNode&amp;lt;S&amp;gt; *);
      binaryTreeNode&amp;lt;S&amp;gt; * FindMax_private(binaryTreeNode&amp;lt;S&amp;gt; *);
      binaryTreeNode&amp;lt;S&amp;gt; * insert_private(S,binaryTreeNode&amp;lt;S&amp;gt; *);
      binaryTreeNode&amp;lt;S&amp;gt; * Delete_private(S,binaryTreeNode&amp;lt;S&amp;gt; *);

  public:
      // BinarySearchTree();
      BinarySearchTree(binaryTreeNode&amp;lt;S&amp;gt; *t,int treesize):linkedBinaryTree&amp;lt;S&amp;gt;(t,treesize){}
                
      // 查找某个元素
      binaryTreeNode&amp;lt;S&amp;gt; * Find(S x,bool iter=false){
          if(iter)return IterFind_private(x,this-&amp;gt;getroot());
          else return Find_private(x,this-&amp;gt;getroot());
      }
      // 查找最大的元素
      binaryTreeNode&amp;lt;S&amp;gt; * FindMin(){return FindMin_private(this-&amp;gt;getroot());}
      // 查找最小的元素
      binaryTreeNode&amp;lt;S&amp;gt; * FindMax(){return FindMax_private(this-&amp;gt;getroot());}
      // 插入一个元素
      void insert(S x){this-&amp;gt;getroot() = insert_private(x,this-&amp;gt;getroot());}
      // 删除一个元素
      void Delete(S x){this-&amp;gt;getroot() = Delete_private(x,this-&amp;gt;getroot());}

      binaryTreeNode&amp;lt;S&amp;gt; * FindMin_public(binaryTreeNode&amp;lt;S&amp;gt; *t){return FindMin_private(t);}
      binaryTreeNode&amp;lt;S&amp;gt; * FindMax_public(binaryTreeNode&amp;lt;S&amp;gt; *t){return FindMax_private(t);}
  };
&lt;/code&gt;&lt;/pre&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;平衡二叉树&lt;/strong&gt;&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;
            &lt;p&gt;二叉搜索树存在的问题：插入节点时，节点的插入次序不同，二叉搜索树的深度和平均查找长度也不同。（最坏的情况是退化为斜二叉树）。&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;在二叉搜索树的基础上考虑一个平衡因子，就得到了平衡二叉树&lt;br /&gt;
  平衡因子：左右子树的高度差&lt;br /&gt;
  平衡二叉树：任意结点的平衡因子绝对值小于等于1&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;平衡二叉树的调整（插入和删除节点可能都需要调整）
            &lt;ul&gt;
              &lt;li&gt;RR旋转&lt;/li&gt;
              &lt;li&gt;RL旋转&lt;/li&gt;
              &lt;li&gt;LL旋转&lt;/li&gt;
              &lt;li&gt;LR旋转&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;&lt;a href=&quot;https://github.com/yang-yang-o-o/Data-Structures-and-Algorithms/blob/a42fae1296568edcd9b66b953def69c31bdae391/Binary_Tree/Balanced_Binary_Tree.h#L14&quot;&gt;C++实现&lt;/a&gt;&lt;/p&gt;

            &lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;  template&amp;lt;class B&amp;gt;
  class BalancedBinaryTree : public linkedBinaryTree&amp;lt;B&amp;gt;
  {
  private:
      binaryTreeNode&amp;lt;B&amp;gt; * FindMin_private(binaryTreeNode&amp;lt;B&amp;gt; *);
      binaryTreeNode&amp;lt;B&amp;gt; * FindMax_private(binaryTreeNode&amp;lt;B&amp;gt; *);
      binaryTreeNode&amp;lt;B&amp;gt; * SingleLeftRotation(binaryTreeNode&amp;lt;B&amp;gt; *);
      binaryTreeNode&amp;lt;B&amp;gt; * DoubleLeftRightRotation(binaryTreeNode&amp;lt;B&amp;gt; *);
      binaryTreeNode&amp;lt;B&amp;gt; * SingleRightRotation(binaryTreeNode&amp;lt;B&amp;gt; *);
      binaryTreeNode&amp;lt;B&amp;gt; * DoubleRightLeftRotation(binaryTreeNode&amp;lt;B&amp;gt; *);
      binaryTreeNode&amp;lt;B&amp;gt; * insert(binaryTreeNode&amp;lt;B&amp;gt; *,B);
      binaryTreeNode&amp;lt;B&amp;gt; * Delete(binaryTreeNode&amp;lt;B&amp;gt; *,B);
  public:
      // BalancedBinaryTree(AVLNode&amp;lt;B&amp;gt;*root,int Treesize):linkedBinaryTree&amp;lt;B&amp;gt;((binaryTreeNode&amp;lt;B&amp;gt;*)root,Treesize){}    // 当节点是结构时可以做强制类型转换
      BalancedBinaryTree(binaryTreeNode&amp;lt;B&amp;gt;*root,int Treesize):linkedBinaryTree&amp;lt;B&amp;gt;(root,Treesize){}       // 当节点是派生类时，可以不强制转换，指向派生类的指针可以向下转换为指向基类的指针。
      void insert(B x){this-&amp;gt;getroot() = insert(this-&amp;gt;getroot(),x);}
      void Delete(B x){this-&amp;gt;getroot() = Delete(this-&amp;gt;getroot(),x);}
      int getheight(binaryTreeNode&amp;lt;B&amp;gt;*t){if(!t)return 0;else return t-&amp;gt;Height;}

  };
&lt;/code&gt;&lt;/pre&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;堆&lt;/strong&gt;&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;特点：
            &lt;ul&gt;
              &lt;li&gt;结构性：用完全二叉树表示&lt;/li&gt;
              &lt;li&gt;有序性：任一结点的关键字是其子树所有结点的最大值（或最小值）&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;主要操作：
            &lt;ul&gt;
              &lt;li&gt;建立&lt;/li&gt;
              &lt;li&gt;插入&lt;/li&gt;
              &lt;li&gt;删除&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;&lt;a href=&quot;https://github.com/yang-yang-o-o/Data-Structures-and-Algorithms/blob/a42fae1296568edcd9b66b953def69c31bdae391/Binary_Tree/MaxHeap.h#L9&quot;&gt;C++实现&lt;/a&gt;&lt;/p&gt;

            &lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;  template&amp;lt;class E&amp;gt;
  class MaxHeap
  {
  private:
      int capacity;   // 堆的最大容量
      int Size;       // 堆中当前存储的有效元素的个数
      E *Data;        // 存储堆的数组
  public:
      MaxHeap(int MaxSize)
      {   Data = new E[MaxSize];
          capacity = MaxSize;
          Size=0;
          Data[0] = numeric_limits&amp;lt;int&amp;gt;::max();//哨兵
      }
      MaxHeap(vector&amp;lt;E&amp;gt; list)// 利用list中的乱序元素创建堆，并实现最大推排序
      {   Data = new E[list.size()+50];
          capacity = list.size()+49;
          Size=0;
          Data[0] = numeric_limits&amp;lt;int&amp;gt;::max();//哨兵
          for(int i=0;i&amp;lt;list.size();i++){
              Data[i+1] = list[i];
              Size++;
          }
          createHeap();
      }
      bool empty(){return Size==0;}
      bool full(){return Size==capacity;}
      bool insert(E);
      void insert_upAdjust(E);
      bool DeleteMax();
      void downAdjst(int,int);// O(logn)
      void upAdjust(int,int);// O(logn)
      void createHeap()//O(n)，证明见算法导论
      {
          for(int i=Size/2;i&amp;gt;=1;--i)//为什么调整是从[size/2,1]，因为完全二叉树的叶子节点数为size/2，因此数组下标[1,size/2]范围内的结点都是非叶子结点。
              downAdjst(i,Size);// 从倒序开始，是因为，downAdjust函数将i位置的元素替换为i的左右结点中最大的那个，然后如果子树需要调整还会调整子树，size/2节点的子节点必然是叶节点，不需要调整子树
                              // ,所以从倒序开始，只需要交换父节点和左右子结点中的较大值即可，不需要重复的去调整子树，子树在上一次for结束时必然是平衡的。
      }
      void deleteTop()//O(logn)
      {
          Data[1]=Data[Size--];// 用最后一个元素覆盖堆顶元素，并让元素个数减1
          downAdjst(1,Size);// 向下调整堆顶元素
      }
      E getMax(){return Data[1];}
  };
&lt;/code&gt;&lt;/pre&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;哈夫曼树&lt;/strong&gt;&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;
            &lt;p&gt;问题：不同的节点连接方式，树的查找效率不同，如何通过改变节点的连接方式来使树的查找效率最高，因此引入哈夫曼树&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;哈夫曼树（最优二叉树）：一棵二叉树按照所有连接方式中带权路径长度最小的连接方式连接得到的树。&lt;br /&gt;
  带权路径长度（WPL）：计算每个叶子节点的权值和根节点到它的路径长度的乘积，最后所有叶子节点求和。&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;构建：
            &lt;ul&gt;
              &lt;li&gt;反复选择两个最小的元素，合并，直到只剩下一个元素。&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;&lt;a href=&quot;https://github.com/yang-yang-o-o/Data-Structures-and-Algorithms/blob/a42fae1296568edcd9b66b953def69c31bdae391/Binary_Tree/Huffman_tree.h#L11&quot;&gt;C++实现&lt;/a&gt;&lt;/p&gt;

            &lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;  template&amp;lt;class H&amp;gt;
  class HuffmanTree : public binaryTreeNode&amp;lt;H&amp;gt;// 从二叉树节点派生，因为哈夫曼树是一种二叉树
  {
  private:
      void combine(int);
      // 构建一个最小堆，因为构造哈夫曼树的过程需要反复选择两个最小的元素，合并，直到只剩下一个元素，因此维护一个最小堆，在logn的时间内
      // 取出最小值
      MinHeap&amp;lt; pair&amp;lt;H,binaryTreeNode&amp;lt;H&amp;gt;*&amp;gt; &amp;gt;* heap;
  public:
      binaryTreeNode&amp;lt;H&amp;gt;* root;// 构造得到的哈夫曼树的根节点
      HuffmanTree(vector&amp;lt;H&amp;gt; list){// 构造函数，接受一个元素无序的vector，然后用这些元素创建一颗哈夫曼树
          vector&amp;lt; pair&amp;lt;H,binaryTreeNode&amp;lt;H&amp;gt;*&amp;gt; &amp;gt; temp;
          for(H i:list)
              temp.push_back(pair&amp;lt;H,binaryTreeNode&amp;lt;H&amp;gt;*&amp;gt;{i,new binaryTreeNode&amp;lt;H&amp;gt;(i)});
          static MinHeap&amp;lt; pair&amp;lt;H,binaryTreeNode&amp;lt;H&amp;gt;*&amp;gt; &amp;gt; minheap(temp,make_pair(numeric_limits&amp;lt;int&amp;gt;::min(),nullptr));// 生成最小堆
          heap = &amp;amp;minheap;
          combine(list.size());// 使用最小堆来快速的创建哈夫曼树
      }
  };

  template&amp;lt;class H&amp;gt;
  void HuffmanTree&amp;lt;H&amp;gt;::combine(int n){// 反复的选择两个最小的元素，合并，直到只剩下一个元素。
      for(int i=1;i&amp;lt;n;i++){
          pair&amp;lt;H,binaryTreeNode&amp;lt;H&amp;gt;*&amp;gt; x = heap-&amp;gt;getMin();heap-&amp;gt;DeleteMin();
          pair&amp;lt;H,binaryTreeNode&amp;lt;H&amp;gt;*&amp;gt; y = heap-&amp;gt;getMin();heap-&amp;gt;DeleteMin();
          binaryTreeNode&amp;lt;H&amp;gt;* Z = new binaryTreeNode&amp;lt;H&amp;gt;(0,x.second,y.second);
          heap-&amp;gt;insert(pair&amp;lt;H,binaryTreeNode&amp;lt;H&amp;gt;*&amp;gt;{0,Z});
      }
      root = heap-&amp;gt;getMin().second;
  }
&lt;/code&gt;&lt;/pre&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;并查集&lt;/strong&gt;&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;
            &lt;p&gt;实现了合并和查找功能的集合&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;&lt;a href=&quot;https://github.com/yang-yang-o-o/Data-Structures-and-Algorithms/blob/a42fae1296568edcd9b66b953def69c31bdae391/Binary_Tree/UFS.h#L10&quot;&gt;C++实现&lt;/a&gt;&lt;/p&gt;

            &lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;  template&amp;lt;class I&amp;gt;
  class Ufs
  {
  public:
      I* root;
      Ufs(vector&amp;lt;array&amp;lt;I,2&amp;gt;&amp;gt; list){//利用list来构造一个并查集
          root = new I[1001]{-1};//数组初始化为-1
          for(auto x:list)
              root[x[0]] = x[1];
      }

      I Find(I);
      void Union(I,I);
      void Visualize(int begin,int end){
          for(int i=begin;i&amp;lt;end;++i)
              cout&amp;lt;&amp;lt;root[i]&amp;lt;&amp;lt;&quot; &quot;;
          cout&amp;lt;&amp;lt;endl;
      }
                
  };

  template&amp;lt;class I&amp;gt;
  I Ufs&amp;lt;I&amp;gt;::Find(I x)//参见浙大慕课
  {
      if(root[x] &amp;lt; 0)// 对于同一个集合来说，只存在一个根节点，且将其作为所属集合的标识
          return x;
      else
          return root[x] = Find(root[x]);//实现了路径压缩，把当前查询节点的路径上的所有节点的父亲都指向根节点
  }

  template&amp;lt;class I&amp;gt;
  void Ufs&amp;lt;I&amp;gt;::Union(I r1,I r2)
  {
      if(root[r2] &amp;lt; root[r1]){
          root[r2] += root[r1];
          root[r1] = r2;
      }
      else{
          root[r1] += root[r2];
          root[r2] = r1;
      }
  }
&lt;/code&gt;&lt;/pre&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;customname2_2&quot;&gt;2.2、多叉树&lt;/h4&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;customname3&quot;&gt;3、图型结构&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;概念&quot;&gt;概念：&lt;/h4&gt;
    &lt;ul&gt;
      &lt;li&gt;有向图&lt;/li&gt;
      &lt;li&gt;无向图&lt;/li&gt;
      &lt;li&gt;简单图&lt;/li&gt;
      &lt;li&gt;邻接、依附&lt;/li&gt;
      &lt;li&gt;无向完全图、有向完全图&lt;/li&gt;
      &lt;li&gt;稠密图、稀疏图&lt;/li&gt;
      &lt;li&gt;顶点的度、入度、出度&lt;/li&gt;
      &lt;li&gt;权、网&lt;/li&gt;
      &lt;li&gt;连通、路径、路径长度、回路&lt;/li&gt;
      &lt;li&gt;简单路径、简单回路&lt;/li&gt;
      &lt;li&gt;子图&lt;/li&gt;
      &lt;li&gt;连通图、连通分量&lt;/li&gt;
      &lt;li&gt;强连通图、强连通分量&lt;/li&gt;
      &lt;li&gt;生成树、生成森林&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;表示&quot;&gt;表示：&lt;/h4&gt;
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;邻接矩阵：遍历的时间复杂度O(n²)&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;邻接表：遍历的时间复杂度O(n+e)&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;比较：&lt;/p&gt;
        &lt;ul&gt;
          &lt;li&gt;同：都能存储有向图和无向图，也都可以存储网图&lt;/li&gt;
          &lt;li&gt;异：
            &lt;ul&gt;
              &lt;li&gt;空间：
                &lt;ul&gt;
                  &lt;li&gt;邻接矩阵O(n²)&lt;/li&gt;
                  &lt;li&gt;邻接表O(n+e)&lt;/li&gt;
                  &lt;li&gt;选择取决于图中边的数目，边多的稠密图用邻接矩阵，边少的稀疏图用邻接表&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
              &lt;li&gt;时间：访问某个节点的所有邻接点
                &lt;ul&gt;
                  &lt;li&gt;邻接表O(e/n)&lt;/li&gt;
                  &lt;li&gt;邻接矩阵O(n)&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
              &lt;li&gt;唯一性：
                &lt;ul&gt;
                  &lt;li&gt;顶点编号确定后，邻接矩阵是唯一的，DFS和BFS的结果是唯一的；邻接表由于插入的次序，不是唯一的，DFS和BFS结果不唯一。&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
              &lt;li&gt;对应关系：
                &lt;ul&gt;
                  &lt;li&gt;邻接表可以看为邻接矩阵中的一行把没有边的位置去掉的结果&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;遍历&quot;&gt;遍历：&lt;/h4&gt;
    &lt;ul&gt;
      &lt;li&gt;深度优先遍历(DFS)：多用于解决连通性问题&lt;/li&gt;
      &lt;li&gt;广度优先遍历(BFS)：多用于解决最短路径问题&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;其他相关算法&quot;&gt;其他相关算法：&lt;/h4&gt;
    &lt;ul&gt;
      &lt;li&gt;最短路径
        &lt;ul&gt;
          &lt;li&gt;单源最短路径
            &lt;ul&gt;
              &lt;li&gt;Dijkstra&lt;/li&gt;
              &lt;li&gt;BF(Bellman-Ford)&lt;/li&gt;
              &lt;li&gt;SPFA&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;多源最短路径
            &lt;ul&gt;
              &lt;li&gt;Floyd&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;最小生成树
        &lt;ul&gt;
          &lt;li&gt;Prim&lt;/li&gt;
          &lt;li&gt;Kruskal&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;拓扑排序&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;c实现&quot;&gt;C++实现&lt;/h4&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;a href=&quot;https://github.com/yang-yang-o-o/Data-Structures-and-Algorithms/blob/a42fae1296568edcd9b66b953def69c31bdae391/Graph/Adjacent_List.h#L46&quot;&gt;邻接表C++实现&lt;/a&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;a href=&quot;https://github.com/yang-yang-o-o/Data-Structures-and-Algorithms/blob/a42fae1296568edcd9b66b953def69c31bdae391/Graph/Adjacent_Matrix.h#L27&quot;&gt;邻接矩阵C++实现&lt;/a&gt;&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;

    &lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;  template&amp;lt;class G&amp;gt;
  class Graph
  {
  private:
      static const int MaxSize_=10;// 预设的图结点最大个数
      G vertex[MaxSize_];// 用于存放图中结点的数组
      int visited[MaxSize_];//={0};// 访问标识数组，和结点数组中相同下标位置的元素为1表示这个结点被访问过，为0没有。

        
        
      // array&amp;lt;G,MaxSize_&amp;gt; vertex;
      int arc[MaxSize_][MaxSize_];// 矩阵，用于表示图中的边
        
  public:
      int VertexNum , arcNum;// 图中结点的数量、边的数量
      int Dist[MaxSize_];//={-1};// 无权单源最短路径中用于标识到源结点距离的数组，Dist[i]表示下标为i的节点到源结点的距离
      int Path[MaxSize_];//={-1};// 无权单源最短路径中用于标识到每个结点经过的上一个节点，用于得到最短路径，Path[i]表示从源结点到达下标为i的结点的路径上前一个结点的下标。

      Graph(vector&amp;lt;G&amp;gt;,vector&amp;lt;array&amp;lt;int,3&amp;gt;&amp;gt;,bool directed = false);
      void initialize(int a[],int val){ // 初始化数组为同一个值
          for(int i=0;i&amp;lt;MaxSize_;++i)
              a[i] = val;
      }
      void DFS(int);
      void BFS(int);    
      void Shootcut_BFS(int);// 最短路径BFS算法
      void Dijkstra_minheap(int);// 基于最小堆的Dijkstra算法
      void Dijkstra_linear_search(int); // 基于线性搜素的Dijkstra算法
      int FindMinDist(){ // 线性搜索最小值算法
          int v,mindist=INT_MAX;
          for(int i=0;i&amp;lt;VertexNum;++i)
              if(visited[i]==0 &amp;amp;&amp;amp; Dist[i]&amp;lt;mindist){// 注意是在所有未访问过的结点中搜索
                  mindist = Dist[i];
                  v = i;
              }
          return mindist &amp;lt; INT_MAX ? v:-1;// 未找到返回-1
      }

      bool Bellman_Ford(int);
      bool SPFA(int);

      bool Floyd(bool visualize=false); // 多源最短路径Floyd算法
      void OutputPath(int i,int j,int P[][MaxSize_]){// 注意这里传递二维数组参数的技巧
          if(i==j)return;// 处理特殊情况
          if(P[i][j]==-1)cout&amp;lt;&amp;lt;j&amp;lt;&amp;lt;&quot; &quot;;// 如果i和j邻接，则直接打印j
                                      // 由于调用OutputPath之前，就已经过滤掉了不能到达的点对，所以这个i一定能到达j，P[i][j]还是初始值-1的话，说明i到j直接没有插入中介点，最短路径就是i-&amp;gt;j
                                      // 同时P[i][j]==-1也表示最短路径中i和j直接相邻接
                                      // 递归终止
          else{// 如果i和j没有邻接，说明中间有中介点，一个已知的中介点就是P[i][j]，因此就可以采用分治的方法，采用递归分别去i到k、k到j间去打印。分治一直分，一直分到i和k邻接、k和j邻接，然后就可以用上面的if打印
              OutputPath(i,P[i][j],P);
              OutputPath(P[i][j],j,P);
          }
      }
      /*
      Floyd算法打印路径还有另一种方式：
          初始化时：P[i][j] = j;
          更新时：  P[i][j] = P[i][k]
          打印时：
                  b = P[i][j];
                  cout&amp;lt;&amp;lt;i;//打印起点
                  while(b != j){
                      cout&amp;lt;&amp;lt;&quot;-&amp;gt;&quot;&amp;lt;&amp;lt;b;//打印中间点
                      b = P[b][j]; // 获取路径上下一个节点
                  }
          P[i][j]存储的始终是i到j的路径中离i最近的那个节点，也就是节点i的下一个。
      */

      // 最小生成树
      bool Prim_minheap(int);
      bool Prim_linear_search(int);
      bool Kruskal();

      bool TopSort();
  };
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;customname4&quot;&gt;4、算法&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;customname1_1&quot;&gt;4.1、排序&lt;/h4&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;冒泡排序&lt;/strong&gt;
        &lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;  template&amp;lt;class S&amp;gt;
  void Bubble_Sort(vector&amp;lt;S&amp;gt;&amp;amp; A)
  {
      int N = A.size();
      for(int P=N-1; P&amp;gt;0; --P){// 每次遍历来确定元素A[P]
          int flag = 0;
          for(int i=0; i&amp;lt;P; ++i)// 一趟冒泡
              if(A[i] &amp;gt; A[i+1]){
                  swap(A[i],A[i+1]);
                  flag = 1;// 标识当前趟发生了交换
              }
          if(flag==0)break;// 如果上一趟没有发生交换，说明已经排好了
      }
  }
&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;插入排序&lt;/strong&gt;
        &lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;  template&amp;lt;class S&amp;gt;
  void Insertion_Sort(vector&amp;lt;S&amp;gt;&amp;amp; A)
  {// 插入排序，将第i个元素插入到[0,i]中正确的位置上，i属于[1,n-1]
      for(int P=1; P&amp;lt;A.size(); ++P){
          S tmp = A[P];// 模下一张牌
          int i;
          for(i=P; i&amp;gt;=1 &amp;amp;&amp;amp; A[i-1]&amp;gt;tmp; --i)// 从摸出的这张牌的位置开始往前遍历，不断把大于摸出的这张牌的牌往后移一个位置。
              A[i] = A[i-1];  // 移出空位
          A[i] = tmp;// 摸出的牌放到正确的位置
      }
  }
&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;希尔排序&lt;/strong&gt;
        &lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;  template&amp;lt;class S&amp;gt;
  void Shell_Sort(vector&amp;lt;S&amp;gt;&amp;amp; A)
  {
  // 希尔排序是插入排序的一种改进，插入排序在小规模数据或者基本有序时很高效
  // 希尔排序能通过预处理提高了对大规模无序数据的效率

      // 根据待排序列长度选择初始增量
      int Sedgewick[] = {929,505,209,109,41,19,5,1,0};// 增量数组，这里只使用了一小部分，可以更多
      int Si;
      for(Si=0;Sedgewick[Si]&amp;gt;=A.size();Si++);// 初始的增量不能超过待排序列的长度

      // 依据初始增量进行希尔排序
      for(int D=Sedgewick[Si]; D&amp;gt;0; D=Sedgewick[++Si])// 从大到小枚举每个可用的增量
          // 对于每个增量D，将待排序列分为D个子序列，
          // 待排序列[0,1,2,3,...,n]
          // 第1个子序列[0,D,2D,...,kD]，第2个子序列[1,D+1,2D+1,...,kD+1],...,第D为子序列[D-1,2D-1,3D-1,...,kD-1]
          // 对于每个子序列，进行插入排序
          // 这里的做法是，从下标D开始往后遍历待排序列中所有的元素，每个元素属于哪个子序列，就在哪个子序列上进行插入排序
          for(int P=D; P&amp;lt;A.size(); ++P){
              S Tmp = A[P];
              int i;
              for(i=P; i&amp;gt;=D &amp;amp;&amp;amp; A[i-D]&amp;gt;Tmp; i-=D)  // 这里的终止条件i&amp;gt;=D是因为后面i要减D，防止越界，(i-D)&amp;gt;=0
                                                  // 从这里 i-=D 就能看出遍历到的每个元素只在其所属的子序列上做插入排序
                  A[i] = A[i-D];
              A[i] = Tmp;
          }
  }
&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;堆排序&lt;/strong&gt;
        &lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;  template&amp;lt;class S&amp;gt;
  void PercDown(vector&amp;lt;S&amp;gt;&amp;amp; A,int p,int N)
  {// 将N个元素的数组中以A[p]为根的子堆调整为最大堆
      int Parent,Child;
      S X = A[p]; // 取出根节点存放的值
      for(Parent = p; (Parent*2+1)&amp;lt;N; Parent=Child){
          Child = Parent*2 + 1;//得到左孩子的下标
          if( (Child!=N-1) &amp;amp;&amp;amp; (A[Child]&amp;lt;A[Child+1]))
              Child++;// 如果右孩子更大，更新为右孩子的下标

          if(X&amp;gt;=A[Child]) // 如果根节点的值已经比他的孩子都大了，就表示找到了合适的位置
              break;
          else            // 如果根节点的值比子节点值小，将孩子值赋给父节点，然后for循环中Parent=Child下滤
              A[Parent] = A[Child]; 
      }
      A[Parent] = X;// 将取出的根节点放到上面for循环找到的合适位置
  }

  template&amp;lt;class S&amp;gt;
  void Heap_Sort2(vector&amp;lt;S&amp;gt;&amp;amp; A)
  {// 基于最大堆实现原地排序
  // 直接在原数组上实现最大堆
      for(int i=A.size()/2-1; i&amp;gt;=0; i--)//初始化最大堆  A.size()/2-1为最下面的度为2的根节点
          PercDown(A,i,A.size());
      for(int i=A.size()-1; i&amp;gt;0; i--){// 将最大堆的堆顶元素换到最后的正确位置上，然后最大堆长度减1，并调整
          swap(A[0],A[i]);// 将最大堆的堆顶元素A[0]交换到后面正确的位置
          PercDown(A,0,i);// 这里一开始将A.size()-1作为N，表示元素个数已经减1
      }
  }
&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;归并排序&lt;/strong&gt;
        &lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;  template&amp;lt;class S&amp;gt;
  void Merge(vector&amp;lt;S&amp;gt;&amp;amp; A,vector&amp;lt;S&amp;gt;&amp;amp; TmpA,int L,int R,int RightEnd)
  {// 合并A中两个相邻有序的子列
  // 左边子列的下标范围为[L,R-1]，右边子列的下标范围为[R,RightEnd]
  // TmpA用于临时存放合并后的结果，最后再将结果复制到A中对应位置上
      int LeftEnd = R-1;
      int Tmp = L;// TmpA的指针
      int t = L;
      int NumElements = RightEnd - L + 1; // 左右子列总的元素个数

      while(L&amp;lt;=LeftEnd &amp;amp;&amp;amp; R&amp;lt;=RightEnd){// 采用三指针策略，将两个有序的子列合并为一个有序的子列
          if(A[L] &amp;lt;= A[R])
              TmpA[Tmp++] = A[L++];
          else
              TmpA[Tmp++] = A[R++];
      }
      // 上面while退出时有三种情况：
      //  1、L &amp;lt;= LeftEnd，R &amp;gt;  RightEnd
      //  2、L &amp;gt;  LeftEnd，R &amp;lt;= RightEnd
      //  3、L &amp;gt;  LeftEnd，R &amp;gt;  RightEnd
      while(L &amp;lt;= LeftEnd)// 对于第1种情况，将左边子列剩下的元素加入TmpA
          TmpA[Tmp++] = A[L++];
      while(R &amp;lt;= RightEnd)// 对于第2种情况，将右边子列剩下的元素加入TmpA
          TmpA[Tmp++] = A[R++];
            
      for(int i=t;i&amp;lt;NumElements+t;++i)// 将合并后的子列复制回A
          A[i] = TmpA[i];
  }
  template&amp;lt;class S&amp;gt;
  void Msort(vector&amp;lt;S&amp;gt;&amp;amp; A,vector&amp;lt;S&amp;gt;&amp;amp; TmpA,int L,int RightEnd)
  {// 递归方式归并排序
  // L、RightEnd初始分别为A的左、右端点下标
      int Center;
      if(L &amp;lt; RightEnd){// 递归终止时 L == RightEnd
          Center = (L+RightEnd)/2;
          Msort(A,TmpA,L,Center);     // 处理左边
          Msort(A,TmpA,Center+1,RightEnd);    // 处理右边
          Merge(A,TmpA,L,Center+1,RightEnd);  // 将左右两边的处理结果合并
          // 递归到最深层时，L+1 == RightEnd，Center等于L，上面两个Msort都被递归终止条件返回，
          // 此时调用这个Merge时，L+1 == RightEnd，Center等于L，这个Merge合并的是下标为L和下标为RightEnd的两个元素
      }
  }
  template&amp;lt;class S&amp;gt;
  void Merge_Sort_recursion(vector&amp;lt;S&amp;gt;&amp;amp; A)
  {// 递归方式归并排序的外部接口函数
      if(A.size()==0)return;
      if(A.size()==1)return;
      vector&amp;lt;S&amp;gt; TmpA(A.size());
      Msort(A,TmpA,0,A.size()-1);
  }
&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;快速排序&lt;/strong&gt;
        &lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;  template&amp;lt;class S&amp;gt;
  S Median3(vector&amp;lt;S&amp;gt;&amp;amp; A,int Left,int Right)
  {
      // 交换，以使A[Left] &amp;lt;= A[Center] &amp;lt;= A[Right]
      int Center = (Left+Right)/2;
      if(A[Left] &amp;gt; A[Center])
          swap(A[Left],A[Center]);
      if(A[Left] &amp;gt; A[Right])
          swap(A[Left],A[Right]);
      if(A[Center] &amp;gt; A[Right])
          swap(A[Center],A[Right]);
      // 将基准Pivot = A[Center] 放到右边，以便后面只需处理A[Left+1]到A[Right-2]
      swap(A[Center],A[Right-1]);
      // 返回基准Pivot
      return A[Right-1];
  }
  template&amp;lt;class S&amp;gt;
  void Qsort(vector&amp;lt;S&amp;gt;&amp;amp; A,int Left,int Right)
  {
      int Pivot,Cutoff=4,Low,High;

      if(Cutoff &amp;lt;= Right-Left){// 元素足够多，才使用快速排序
      // 如果只使用快排，不使用插入排序，这个if-else要取消，然后要加递归终止条件，分别在Right-Left == 0,1,2,时处理，也就是分别处理1,2,3个元素的情况
          Pivot = Median3(A,Left,Right); // 求主元
          Low = Left;                     
          High = Right-1;                // 指定双指针的初始值
          while(1){// 将序列中比主元小的移到主元左边，大的移到右边
              while(A[++Low] &amp;lt; Pivot);    // 左边找到第一个大于等于Pivot的元素
              while(A[--High] &amp;gt; Pivot);   // 右边找到第一个小于等于Pivot的元素
              if(Low &amp;lt; High)              // 如果还没有遍历完毕，交换双指针指向的两个元素
                  swap(A[Low],A[High]);
              else                        // 遍历完毕退出
                  break;
          }
          swap(A[Low],A[Right-1]);        // 遍历完毕后Low所指的位置是主元的最终正确的位置，直接交换
                          // 换Low的另一种解释，Low是比主元大的，换了以后，比主元大的全在右边，小的全在左边才能分治
                          // 如果一开始选主元时，将主元放到Low+1的位置，那么就要交换High了
          // 从下面分治的范围可以看出，只有Low没有被分治
          Qsort(A,Left,Low-1);            // 递归处理交换后的主元的左边元素
          Qsort(A,Low+1,Right);           // 递归处理交换后的主元的右边元素
      }
      else                    // 元素太少，使用插入排序
          Insertion_Sort(A);  
  }
  template&amp;lt;class S&amp;gt;
  void QuickSort(vector&amp;lt;S&amp;gt;&amp;amp; A)
  {// 快速排序外部接口
      Qsort(A,0,A.size()-1);
  }
&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;性能比较&lt;/strong&gt;&lt;/p&gt;

        &lt;p&gt;&lt;!-- ![Markdowm Image](/assets\DataStructures_Algorithms\image_1.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets/DataStructures_Algorithms\image_1.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;customname1_2&quot;&gt;4.2、查找&lt;/h4&gt;

    &lt;ul&gt;
      &lt;li&gt;线性表：
        &lt;ul&gt;
          &lt;li&gt;顺序查找&lt;/li&gt;
          &lt;li&gt;二分查找&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;树表：
        &lt;ul&gt;
          &lt;li&gt;二叉搜索树&lt;/li&gt;
          &lt;li&gt;平衡二叉树&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;散列表&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;customname1_3&quot;&gt;4.3、索引&lt;/h4&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;customname1_4&quot;&gt;4.4、分治&lt;/h4&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;customname1_5&quot;&gt;4.5、回溯&lt;/h4&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;customname1_6&quot;&gt;4.6、贪心&lt;/h4&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;customname1_7&quot;&gt;4.7、动态规划&lt;/h4&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="blog" /><category term="C++" /><summary type="html">目录</summary></entry><entry><title type="html">Machine Learning</title><link href="http://localhost:4000/Machine-Learning/" rel="alternate" type="text/html" title="Machine Learning" /><published>2022-12-24T23:38:00+08:00</published><updated>2022-12-24T23:38:00+08:00</updated><id>http://localhost:4000/Machine%20Learning</id><content type="html" xml:base="http://localhost:4000/Machine-Learning/">&lt;h2 id=&quot;目录&quot;&gt;目录&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h3 id=&quot;1k-means&quot;&gt;&lt;a href=&quot;#customname1&quot;&gt;1、K-means&lt;/a&gt;&lt;/h3&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h3 id=&quot;2pca&quot;&gt;&lt;a href=&quot;#customname2&quot;&gt;2、PCA&lt;/a&gt;&lt;/h3&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h3 id=&quot;3svd&quot;&gt;&lt;a href=&quot;#customname3&quot;&gt;3、SVD&lt;/a&gt;&lt;/h3&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h3 id=&quot;4策略&quot;&gt;&lt;a href=&quot;#customname3&quot;&gt;4、策略&lt;/a&gt;&lt;/h3&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;customname1&quot;&gt;1、K-means&lt;/h3&gt;

&lt;!-- ![Markdowm Image](/assets\Machine_Learning\image_1.png) --&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets/Machine_Learning\image_1.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;KNN&lt;/strong&gt;
  计算当前样本和数据库中所有样本的距离，然后将距离排序，取最小的k 个距离对应的数据库样本，分析k 个样本的类别，取类别频率最高的类别作为当前样本的类别。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;K-means&lt;/strong&gt;
  创建k 个初始聚类中心，每个数据点都分别计算到k 个聚类中心的距离，然后将每个数据点分到距离最近的聚类中心上，得到k 堆，然后计算每堆的均值作为新的聚类中心。然后重复上面的步骤，直到每个样本的类别都不改变。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;customname2&quot;&gt;2、PCA&lt;/h3&gt;

&lt;!-- ![Markdowm Image](/assets\Machine_Learning\image_2.png) --&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets/Machine_Learning\image_2.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;当我们用一些特征来表示数据时，特征间可能出现冗余，此时可以通过PCA 将数据的特征降维。以实现用更低维度、更少、更显著的特征来表示数据。通常的做法先将数据归一化为0 均值1 方差，然后求数据的平方和矩阵
&lt;!-- ![Markdowm Image](/assets\Machine_Learning\image_4.png) --&gt;
&lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets/Machine_Learning\image_4.png&quot; alt=&quot;Markdowm Image&quot; /&gt;
，对这个矩阵奇异值分解，U 矩阵的列向量是源数据列空间的标准正交基，取前k 个列向量就构成一个子空间，然后数据左乘k 个列向量构成的矩阵，就将源数据投影到了子空间，实现数据的降维。&lt;/p&gt;

&lt;h3 id=&quot;customname3&quot;&gt;3、SVD&lt;/h3&gt;

&lt;!-- ![Markdowm Image](/assets\Machine_Learning\image_3.png) --&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets/Machine_Learning\image_3.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;只有方阵才能进行特征分解，特征分解将矩阵分解为特征向量张成的矩阵和特征值构成的对角阵的乘积。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;奇异值分解不要求矩阵为方阵，一个mxn 的矩阵可以分解为mxm 的酉矩阵、mxn 的对角阵、nxn 的酉矩阵三者的乘积。对角阵中对角元为奇异值。共轭转置等于逆矩阵称为酉矩阵。酉矩阵中每个元素都为实数变为正交矩阵。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;https://zhuanlan.zhihu.com/p/29846048&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;customname4&quot;&gt;4、策略&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;一开始先从简单的算法快速暴力的开始：通过分析算法的误差决定下一步做什么，通过数字评估指标来验证你想加入算法中的新想法是否能提高效果，进一步决定算法应该包含什么而不应该包含什么。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;一种简单的查看描述特征是否足够的方法就是想想这些特征给人类的专家，其是否能预测出正确的结果。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在数据增强时要考虑的最重要的一点就是增强后的数据有没有代表性，也就是对最终提高模型的性能有没有很大的作用。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="blog" /><category term="CV" /><summary type="html">目录</summary></entry><entry><title type="html">CNN</title><link href="http://localhost:4000/CNN/" rel="alternate" type="text/html" title="CNN" /><published>2022-12-23T23:38:00+08:00</published><updated>2022-12-23T23:38:00+08:00</updated><id>http://localhost:4000/CNN</id><content type="html" xml:base="http://localhost:4000/CNN/">&lt;h2 id=&quot;目录&quot;&gt;目录&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h3 id=&quot;1基础网络&quot;&gt;&lt;a href=&quot;#customname1&quot;&gt;1、基础网络&lt;/a&gt;&lt;/h3&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h3 id=&quot;2目标检测&quot;&gt;&lt;a href=&quot;#customname2&quot;&gt;2、目标检测&lt;/a&gt;&lt;/h3&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;customname1&quot;&gt;1、基础网络&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;lenet-5&quot;&gt;LeNet-5&lt;/h4&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;alexnet&quot;&gt;AlexNet&lt;/h4&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;vgg&quot;&gt;VGG&lt;/h4&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;resnet&quot;&gt;ResNet&lt;/h4&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;!-- ![Markdowm Image](/assets\CNN\image_1.png) --&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets/CNN\image_1.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;残差结构可以解决梯度消失、梯度爆炸的问题。有用的原因是残差块学习恒等函数非常容易。在学习过程中自动决定使用或者不使用某些层。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;densenet&quot;&gt;DenseNet&lt;/h4&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;每一层都使用前面所有层的输出。能够充分的利用特征，加强特征的传递。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;inception&quot;&gt;Inception&lt;/h4&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;!-- ![Markdowm Image](/assets\CNN\image_3.png) --&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets/CNN\image_3.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;多个并行分支（比如不同尺度卷积），在通道上堆叠各分支的输出，让网络自动决定使用哪些分支&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;1x1-convolution&quot;&gt;1x1 convolution&lt;/h4&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;!-- ![Markdowm Image](/assets\CNN\image_2.png) --&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets/CNN\image_2.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;1x1 卷积相当于全连接层，可以在通道上融合信息，可以实现通道的压缩，压缩通道后就得到了瓶颈层，压缩通道既降低了计算复杂度，又不影响网络的性能。&lt;/p&gt;

&lt;h3 id=&quot;customname2&quot;&gt;2、目标检测&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;传统方法滑动窗口--简单分类器&quot;&gt;传统方法：滑动窗口 + 简单分类器&lt;/h4&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;anchor-base&quot;&gt;Anchor base&lt;/h4&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;卷积并行的实现滑动窗口
  优点：效率高
  缺点：边界框的位置可能不够准确&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;交并比&lt;/p&gt;

        &lt;p&gt;&lt;!-- ![Markdowm Image](/assets\CNN\image_4.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets/CNN\image_4.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;交并比损失&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;
            &lt;p&gt;IOU loss&lt;/p&gt;

            &lt;p&gt;&lt;!-- ![Markdowm Image](/assets\CNN\image_5.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets/CNN\image_5.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;GIOU loss&lt;/p&gt;

            &lt;p&gt;&lt;!-- ![Markdowm Image](/assets\CNN\image_6.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets/CNN\image_6.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;DIOU loss&lt;/p&gt;

            &lt;p&gt;&lt;!-- ![Markdowm Image](/assets\CNN\image_7.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets/CNN\image_7.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;CIOU loss&lt;/p&gt;

            &lt;p&gt;&lt;!-- ![Markdowm Image](/assets\CNN\image_8.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets/CNN\image_8.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;&lt;strong&gt;IOU 系列loss&lt;/strong&gt;
  使用mse 计算坐标损失时，坐标差相同，损失就相同，但是同样的坐标差对于大的bbx 相对误差就很小，对于小的bbx，相对误差就很大。IOU 是一种尺度不变的表示，使用IOU loss 就能解决这个问题。&lt;/p&gt;
            &lt;ul&gt;
              &lt;li&gt;IOU loss：IOU 的负对数。不相交时，IOU loss 不可导；相交面积相同，IOU loss 就相同&lt;/li&gt;
              &lt;li&gt;GIOU loss：（当目标框完全包裹预测框时，退化为IOU loss）
  &lt;!-- ![Markdowm Image](/assets\CNN\image_11.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets/CNN\image_11.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/li&gt;
              &lt;li&gt;DIOU loss：同时考虑重叠面积和中心点距离
  &lt;!-- ![Markdowm Image](/assets\CNN\image_12.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets/CNN\image_12.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/li&gt;
              &lt;li&gt;CIOU loss：在DIOU loss 基础上增加考虑长宽比
  &lt;!-- ![Markdowm Image](/assets\CNN\image_13.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets/CNN\image_13.png&quot; alt=&quot;Markdowm Image&quot; /&gt;
  &lt;!-- ![Markdowm Image](/assets\CNN\image_14.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets/CNN\image_14.png&quot; alt=&quot;Markdowm Image&quot; /&gt;
  &lt;!-- ![Markdowm Image](/assets\CNN\image_15.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets/CNN\image_15.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Anchor Boxes&lt;/p&gt;

        &lt;p&gt;&lt;!-- ![Markdowm Image](/assets\CNN\image_9.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets/CNN\image_9.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;非极大值抑制&lt;/p&gt;

        &lt;p&gt;&lt;!-- ![Markdowm Image](/assets\CNN\image_10.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets/CNN\image_10.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;Faster Rcnn、SSD
        &lt;ul&gt;
          &lt;li&gt;Faster Rcnn：特征提取层，比如使用VGG；RPN 网格预测出候选区域；ROI pooling 在特征图的候选区域上提取特征送入全连接层预测候选区域的类别和优化候选框。&lt;/li&gt;
          &lt;li&gt;SSD：特征提取层提取特征，使用FPN 在不同尺度上输出特征图。每个特征图的每个位置都设置anchor ，然后分两个分支，一个分支卷积得到anchor_num*4，一个分支卷积得到anchor_num*C，然后根据每个类别的预测概率做NMS&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;YOLO 系列
        &lt;ul&gt;
          &lt;li&gt;YOLOv1：20%随机裁剪，HSV，网络输出SxSx(2x5+20)，正样本计算坐标损失和置信度损失，负样本计算置信度损失，cell 计算类别损失。损失都采用mse。处理正负样本不均衡：正样本置信度损失时负样本的50 倍，同时只有与任何gt bbx IOU 小于0.5 的设为负样本。&lt;br /&gt;
  缺点：对小物体预测较差，每个cell 只能预测两个bbx 和一个类别。&lt;/li&gt;
          &lt;li&gt;YOLOv2：在v1 的基础上加入BN、5 种anchor（使用1-IOU 作为k 均值聚类的距离），宽高预测为基于anchor 的偏移、多尺度训练、Darknet19。网络输出SxSx5x(5+80)。坐标和置信度损失使用mse，类别使用交叉熵&lt;/li&gt;
          &lt;li&gt;YOLOv3：置信度损失采用逻辑回归、类别损失bce，坐标损失mse，增加了多尺度预测，在三个尺度上预测，9 种anchor，每个尺度分3 个。Darknet53、多尺度训练。&lt;/li&gt;
          &lt;li&gt;YOLOv4：mosaic 数据增强、DropBlock regularization、Class label smoothing、Mish activation、CSP、CIOU-loss、交叉小批标准化(CmBN)、SPP（用于扩大感受野）、PAN（用于多尺度特征集成）、DIoU-NMS。
            &lt;ul&gt;
              &lt;li&gt;CSPDarknet53：CSP 增强CNN 的学习能力&lt;/li&gt;
              &lt;li&gt;SPP：空间金字塔池化，可以显著增加感受野&lt;/li&gt;
              &lt;li&gt;PANet：通过上采用之后又下采用来聚合特征。&lt;/li&gt;
              &lt;li&gt;坐标损失CIOU，置信度损失bce，分类损失bce。&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;YOLOv5：mosaic 中增加随机缩放，随机排布；自适应anchor_size；推理时自适应图片缩放。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Pytorch 中的dataSet，dataloader，Sampler&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;anchor-free&quot;&gt;Anchor free&lt;/h4&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="blog" /><category term="CV" /><summary type="html">目录</summary></entry><entry><title type="html">Deep Learning</title><link href="http://localhost:4000/Deep-Learning/" rel="alternate" type="text/html" title="Deep Learning" /><published>2022-12-22T10:01:00+08:00</published><updated>2022-12-22T10:01:00+08:00</updated><id>http://localhost:4000/Deep%20Learning</id><content type="html" xml:base="http://localhost:4000/Deep-Learning/">&lt;h2 id=&quot;目录&quot;&gt;目录&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h3 id=&quot;1数据&quot;&gt;&lt;a href=&quot;#customname1&quot;&gt;1、数据&lt;/a&gt;&lt;/h3&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;h4 id=&quot;11数据预处理&quot;&gt;&lt;a href=&quot;#customname1_1&quot;&gt;1.1、数据预处理&lt;/a&gt;&lt;/h4&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;h4 id=&quot;12数据集划分&quot;&gt;&lt;a href=&quot;#customname1_2&quot;&gt;1.2、数据集划分&lt;/a&gt;&lt;/h4&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h3 id=&quot;2网络结构&quot;&gt;&lt;a href=&quot;#customname2&quot;&gt;2、网络结构&lt;/a&gt;&lt;/h3&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;h4 id=&quot;21cnn&quot;&gt;&lt;a href=&quot;#customname2_1&quot;&gt;2.1、CNN&lt;/a&gt;&lt;/h4&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;h4 id=&quot;22fc&quot;&gt;&lt;a href=&quot;#customname2_2&quot;&gt;2.2、FC&lt;/a&gt;&lt;/h4&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;h4 id=&quot;23transformer&quot;&gt;&lt;a href=&quot;#customname2_3&quot;&gt;2.3、Transformer&lt;/a&gt;&lt;/h4&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h3 id=&quot;3参数设置&quot;&gt;&lt;a href=&quot;#customname3&quot;&gt;3、参数设置&lt;/a&gt;&lt;/h3&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h3 id=&quot;4损失函数&quot;&gt;&lt;a href=&quot;#customname4&quot;&gt;4、损失函数&lt;/a&gt;&lt;/h3&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h3 id=&quot;5前向传播&quot;&gt;&lt;a href=&quot;#customname5&quot;&gt;5、前向传播&lt;/a&gt;&lt;/h3&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h3 id=&quot;6反向传播&quot;&gt;&lt;a href=&quot;#customname6&quot;&gt;6、反向传播&lt;/a&gt;&lt;/h3&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h3 id=&quot;7梯度下降&quot;&gt;&lt;a href=&quot;#customname7&quot;&gt;7、梯度下降&lt;/a&gt;&lt;/h3&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h3 id=&quot;8训练中&quot;&gt;&lt;a href=&quot;#customname8&quot;&gt;8、训练中&lt;/a&gt;&lt;/h3&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h3 id=&quot;9可视化&quot;&gt;&lt;a href=&quot;#customname9&quot;&gt;9、可视化&lt;/a&gt;&lt;/h3&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h3 id=&quot;10评估&quot;&gt;&lt;a href=&quot;#customname10&quot;&gt;10、评估&lt;/a&gt;&lt;/h3&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h3 id=&quot;11算法调整&quot;&gt;&lt;a href=&quot;#customname11&quot;&gt;11、算法调整&lt;/a&gt;&lt;/h3&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;customname1&quot;&gt;1、数据&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;customname1_1&quot;&gt;1.1、数据预处理&lt;/h4&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;h5 id=&quot;数据增强&quot;&gt;数据增强&lt;/h5&gt;

        &lt;ul&gt;
          &lt;li&gt;
            &lt;p&gt;畸变&lt;/p&gt;

            &lt;p&gt;&lt;!-- ![Markdowm Image](/assets\Deep_Learning\image_11.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets/Deep_Learning\image_11.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;图像遮挡&lt;/p&gt;

            &lt;ul&gt;
              &lt;li&gt;
                &lt;p&gt;随机擦除&lt;/p&gt;

                &lt;p&gt;&lt;!-- ![Markdowm Image](/assets\Deep_Learning\image_13.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets/Deep_Learning\image_13.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;
              &lt;/li&gt;
              &lt;li&gt;
                &lt;p&gt;Cutout&lt;/p&gt;

                &lt;p&gt;&lt;!-- ![Markdowm Image](/assets\Deep_Learning\image_14.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets/Deep_Learning\image_14.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;
              &lt;/li&gt;
              &lt;li&gt;
                &lt;p&gt;Hide and Seek&lt;/p&gt;

                &lt;p&gt;&lt;!-- ![Markdowm Image](/assets\Deep_Learning\image_15.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets/Deep_Learning\image_15.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;
              &lt;/li&gt;
              &lt;li&gt;
                &lt;p&gt;Grid Mask&lt;/p&gt;

                &lt;p&gt;&lt;!-- ![Markdowm Image](/assets\Deep_Learning\image_16.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets/Deep_Learning\image_16.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;
              &lt;/li&gt;
              &lt;li&gt;
                &lt;p&gt;MixUp&lt;/p&gt;

                &lt;p&gt;&lt;!-- ![Markdowm Image](/assets\Deep_Learning\image_17.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets/Deep_Learning\image_17.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;
              &lt;/li&gt;
              &lt;li&gt;
                &lt;p&gt;CutMix&lt;/p&gt;

                &lt;p&gt;&lt;!-- ![Markdowm Image](/assets\Deep_Learning\image_18.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets/Deep_Learning\image_18.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;
              &lt;/li&gt;
              &lt;li&gt;
                &lt;p&gt;mosaic&lt;/p&gt;

                &lt;p&gt;&lt;!-- ![Markdowm Image](/assets\Deep_Learning\image_19.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets/Deep_Learning\image_19.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;
              &lt;/li&gt;
              &lt;li&gt;
                &lt;p&gt;style transfer GAN&lt;/p&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;&lt;strong&gt;数据增强方式有哪些？&lt;/strong&gt;
  畸变和图像遮挡。畸变又分为光照畸变和几何畸变，光照畸变比如改变HSV 等，几何畸变比如缩放、仿射变换，裁剪。图像遮挡有随机擦除、cutout、mixup、cutmix、mosaic。&lt;/p&gt;
            &lt;ul&gt;
              &lt;li&gt;随机擦除：可以在输入图像上擦除、也可以在特征图上擦除，Dropout（随机失活神经元）、DropConnect（随机失活连接）、DropBlock（在卷积输出的特征图中随机将一个区域置0）&lt;/li&gt;
              &lt;li&gt;Cutout：随机左上角的一个固定大小的正方形区域置0.&lt;/li&gt;
              &lt;li&gt;Mixup：直接将两张图像利用α通道混合，拥有两个标签，loss 可以分别计算每个标签的loss，然后安装α加权。&lt;/li&gt;
              &lt;li&gt;CutMix：从另一张图像上裁剪一个区域贴到当前图像上，在区域中保留原图的bbx。&lt;/li&gt;
              &lt;li&gt;Mosaic：从4 张图像上裁剪得到4 个区域，然后拼接4 个区域得到一张图像，在区域中保留原图的bbx。好处是一张图像同时混合了4 中上下文信息，在BN 时就能同时考虑4 倍的信息，就能得到近似4 倍batch-size 的BN 效果。&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;h5 id=&quot;归一化&quot;&gt;归一化&lt;/h5&gt;

        &lt;p&gt;&lt;!-- ![Markdowm Image](/assets\Deep_Learning\image_12.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets/Deep_Learning\image_12.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;&lt;strong&gt;输入数据为何要归一化、如何归一化？&lt;/strong&gt;
  当输入数据各个维度上的范围相差很大时，对输入数据归一化为0 均值1 方差，这样能加速收敛&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;customname1_2&quot;&gt;1.2、数据集划分&lt;/h4&gt;

    &lt;p&gt;&lt;!-- ![Markdowm Image](/assets\Deep_Learning\image_20.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets/Deep_Learning\image_20.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;什么是n 份交叉验证，有什么好处，如何用于模型评估？&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;是一种用于模型选择的策略，将数据集划分为n 份，对于一个模型训练n 次，每次使用其中1份作为验证集、其余n-1 份作为训练集，取n 次训练的平均误差。多个模型时根据平均误差来选择模型。这种策略的好处是可以避免固定划分数据集时的局限性、特殊性。尤其在小规模数据集上能减小过拟合。&lt;/li&gt;
          &lt;li&gt;将这种策略用于训练集和测试集时，可以进行模型评估，每次用其中1 份作为测试集，n-1 份作为训练集，同一个模型训练n 次，取平均误差作为模型的评估结果。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;customname2&quot;&gt;2、网络结构&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;customname2_1&quot;&gt;2.1、CNN&lt;/h4&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;卷积&lt;/p&gt;

        &lt;p&gt;&lt;!-- ![Markdowm Image](/assets\Deep_Learning\image_21.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets/Deep_Learning\image_21.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

        &lt;p&gt;&lt;!-- ![Markdowm Image](/assets\Deep_Learning\image_22.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets/Deep_Learning\image_22.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;&lt;strong&gt;传统卷积、Depthwise Convolution 、Pointwise Convolution 、Depthwise Separable Convolution、分组卷积、空洞卷积的具体做法？&lt;/strong&gt;
            &lt;ul&gt;
              &lt;li&gt;Depthwise Convolution：对每个通道单独卷积，卷积核个数为输入通道数，卷积前后通道数不变。不能融合不同通道的信息。&lt;/li&gt;
              &lt;li&gt;Pointwise Convolution：卷积核固定为1x1xC，就是1x1 卷积。&lt;/li&gt;
              &lt;li&gt;Depthwise Separable Convolution：先进行Depthwise Convolution，然后Pointwise Convolution。&lt;/li&gt;
              &lt;li&gt;空洞卷积：在卷积核中插入空白数据，目的是增大感受野。&lt;/li&gt;
              &lt;li&gt;分组卷积：将输入在通道上分为多个组，输出通道也分为多个组，每个组直接单独卷积。每个卷积核的尺寸变为（N/G，K，K），参数量变为原来的1/G。&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;&lt;strong&gt;在计算机视觉领域，为什么卷积核的尺寸通常为奇数：&lt;/strong&gt;
  原因有三点：
            &lt;ul&gt;
              &lt;li&gt;1、如果是一个偶数，那么same padding 时就只能非对称填充，奇数时直接填充卷积核的单边，更自然对称。&lt;/li&gt;
              &lt;li&gt;2、奇数的卷积核有一个central pixel 可以方便的确定position。&lt;/li&gt;
              &lt;li&gt;3、奇数相对于偶数，有中心，对边缘、对线条更加敏感，可以更有效的提取信息。如果使用偶数尺寸的卷积核应该也能得到不错的结果，但是在计算机视觉领域，通常使用奇数尺寸的卷积核。&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;&lt;strong&gt;卷积的特点？&lt;/strong&gt;
  参数共享和稀疏连接。
            &lt;ul&gt;
              &lt;li&gt;参数共享：卷积核在卷积的过程中，是整张图像共用的，卷积核的参数是在不同的卷积区域之间共享的。&lt;/li&gt;
              &lt;li&gt;稀疏连接：卷积输出的某个值，只有对应的卷积区域有关，与其他区域无关，当前的值只连接到了这个区域，没有连接到其他区域。&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;&lt;strong&gt;上采样分为哪几种？&lt;/strong&gt;
  UNpooling、转置卷积/反卷积；
            &lt;ul&gt;
              &lt;li&gt;UNpooling 又分为补0、补邻近值、max UNpooling（补0）&lt;/li&gt;
              &lt;li&gt;转置卷积/反卷积：卷积核在输出图上滑动，将输入的一个值乘以卷积核得到输出图上的多个值，然后滑动过程中重叠位置相加。&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;BN&lt;/p&gt;

        &lt;p&gt;&lt;!-- ![Markdowm Image](/assets\Deep_Learning\image_23.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets/Deep_Learning\image_23.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;&lt;strong&gt;BN 的作用、训练时和推理时BN 的计算细节、BN 参数的维度。&lt;/strong&gt;
  BN 将卷积输出的尺度调整到统一的区间，减少数据的发散程度，降低网络的学习难度，加速收敛，减弱了前层参数和后层参数的联系，有轻微的正则效果，避免梯度消失和梯度爆炸。&lt;strong&gt;BN 的精髓在于归一化后使用β和γ作为还原参数，用于保留原数据的分布。&lt;/strong&gt;
            &lt;ul&gt;
              &lt;li&gt;训练阶段：计算当前batch 上的均值和方差，然后归一化，然后乘γ加β。然后用均值和方差去更新滑动平均值。&lt;/li&gt;
              &lt;li&gt;推理阶段：使用训练阶段最后的滑动平均值作为均值和方差来归一化，然后用训练得到的γ和β来还原分布。
  &lt;!-- ![Markdowm Image](/assets\Deep_Learning\image_27.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets/Deep_Learning\image_27.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/li&gt;
              &lt;li&gt;参数维度：均值、方差、γ、β的维度都是卷积输出的通道数目，也就是说是在通道维度上BN。&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;激活&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;
            &lt;p&gt;线性激活&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;非线性激活
  Sigmoid、tanh、Relu、leak relu、maxout
  &lt;!-- ![Markdowm Image](/assets\Deep_Learning\image_24.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets/Deep_Learning\image_24.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;dropout&lt;/p&gt;

            &lt;p&gt;&lt;!-- ![Markdowm Image](/assets\Deep_Learning\image_25.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets/Deep_Learning\image_25.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

            &lt;ul&gt;
              &lt;li&gt;&lt;strong&gt;Dropout 的作用、训练和推理时的计算细节&lt;/strong&gt;
  能够消除特征间的相互适应，使模型在不需要所有特征都有时才能决策。训练时以一定的概率置0 一些元素，然后将未被置0 的每个元素都除以概率，保证当前层的期望不变。推理时不使用Dropout。&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;池化&lt;/p&gt;

        &lt;p&gt;&lt;!-- ![Markdowm Image](/assets\Deep_Learning\image_26.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets/Deep_Learning\image_26.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;customname2_2&quot;&gt;2.2、FC&lt;/h4&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;customname2_3&quot;&gt;2.3、Transformer&lt;/h4&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;customname3&quot;&gt;3、参数设置&lt;/h3&gt;

&lt;!-- ![Markdowm Image](/assets\Deep_Learning\image_10.png) --&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets/Deep_Learning\image_10.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;customname4&quot;&gt;4、损失函数&lt;/h3&gt;

&lt;!-- ![Markdowm Image](/assets\Deep_Learning\image_9.png) --&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets/Deep_Learning\image_9.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;L1 正则和L2 正则具体做法、为什么L1 正则比L2 正则稀疏？为什么正则项能减小过拟合？&lt;/strong&gt;
  L1 正则项为网络每个权重求L1 范数（矩阵中每个元素的绝对值之和），然后所有权重求和，损失函数中加入L1 正则项，损失函数对于某个权重的偏导数中就只有λsgn(w)这一项，乘以学习率得到ηλsgn(w)，根据权重的L1 范数的符号决定加减ηλ。无论当前权重的大小，总是加减一个固定的项。
  &lt;!-- ![Markdowm Image](/assets\Deep_Learning\image_28.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets/Deep_Learning\image_28.png&quot; alt=&quot;Markdowm Image&quot; /&gt;
  L2 正则项为网络每个权重求L2 范数（每个元素的平方和的平方根），然后所有权重求和，损失函数中加入L2 正则项，损失函数对于某个权重的偏导数中就只有ηλw 这一项，合并到w 中又叫权重衰减
  &lt;!-- ![Markdowm Image](/assets\Deep_Learning\image_29.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets/Deep_Learning\image_29.png&quot; alt=&quot;Markdowm Image&quot; /&gt;
  权重每次乘以一个小于1 的数。因为L1 正则对于权重的影响每次都下降一个固定的值，因此不会保留很多很小的值，而是有很多为0 的值，因此得到的权重w 就稀疏。L2 正则对于权重的影响使得权重每次都乘以一个小于1 的数，当w 本身很小时，下降就变慢，最后不会完全等于0，因此有很多接近于0 的值，没有L1 稀疏。&lt;strong&gt;正则项的本质就是通过减小权重w 来达到简化模型的目的，对于输入数据增加噪声之后，模型输出受影响的减小。&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Softmax+交叉熵损失求导过程？&lt;/strong&gt;
  &lt;!-- ![Markdowm Image](/assets\Deep_Learning\image_30.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets/Deep_Learning\image_30.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;customname5&quot;&gt;5、前向传播&lt;/h3&gt;

&lt;!-- ![Markdowm Image](/assets\Deep_Learning\image_8.png) --&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets/Deep_Learning\image_8.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;滑动平均的优点、如何计算、偏差修正如何做？&lt;/strong&gt;
  使用滚动变量来求平均值，内存占用小，计算效率高。
  &lt;!-- ![Markdowm Image](/assets\Deep_Learning\image_31.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets/Deep_Learning\image_31.png&quot; alt=&quot;Markdowm Image&quot; /&gt;
  近似于前1/（1-β）个数据的平均值。偏差修正：
  &lt;!-- ![Markdowm Image](/assets\Deep_Learning\image_32.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets/Deep_Learning\image_32.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;customname6&quot;&gt;6、反向传播&lt;/h3&gt;

&lt;!-- ![Markdowm Image](/assets\Deep_Learning\image_7.png) --&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets/Deep_Learning\image_7.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;标量、向量、矩阵间相互求导规则？&lt;/strong&gt;
  除了矩阵和行向量之间的导数是前者对于后者的每个元素分别求导，其他的都是前者的每个元素分别对于后者求导。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;为什么会出现梯度消失和梯度爆炸？&lt;/strong&gt;
  因为当前层对于上一层的导数需要乘以当前层的权重，如果w 被调整到比单位矩阵小，那么对于反向传播的梯度是有缩小的作用，在深层网络中，如果梯度不断被缩小，就会出现梯度消失问题，如果w 被调整到比单位矩阵大，对于梯度有放大作用，就会出现梯度爆炸的问题。激活函数有时也会影响梯度，比如sigmoid 函数饱和时，梯度很小，最终如果w 也缩小梯度，那么就会出现梯度消失。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;如何解决梯度消失和梯度爆炸？&lt;/strong&gt;
  正确选择激活函数、使用残差结构、使用BN&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;customname7&quot;&gt;7、梯度下降&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;定义&quot;&gt;定义&lt;/h4&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;!-- ![Markdowm Image](/assets\Deep_Learning\image_5.png) --&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets/Deep_Learning\image_5.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;为什么梯度的反方向是loss 下降最快的方向？&lt;/strong&gt;
  因为将损失函数在当前位置一阶泰勒展开，保留一阶项，一阶项是增量向量和梯度向量的点乘，等于模长的乘积乘以夹角的余弦值，当增量向量和梯度向量反向时，点乘最小，损失函数最小，此时增量向量的方向就是负梯度方向。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;常用方法&quot;&gt;常用方法&lt;/h4&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;!-- ![Markdowm Image](/assets\Deep_Learning\image_6.png) --&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets/Deep_Learning\image_6.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;SGD、GD、mini-batch SGD 的区别？&lt;/strong&gt;
  mini-batch 既能加快收敛速度，所需要的硬件内存又不会过大。如果不考虑硬件，肯定是GD收敛速度最快。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;SGDM、Adagrad、RMSProp、ADAM 各自具体的做法和优缺点？&lt;/strong&gt;
  SGDM 在SGD 的基础上用梯度的滑动平均值来代替梯度，引入之前梯度的影响，能加快收敛速度。
  &lt;!-- ![Markdowm Image](/assets\Deep_Learning\image_33.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets/Deep_Learning\image_33.png&quot; alt=&quot;Markdowm Image&quot; /&gt;
  Adagrad 累加梯度的平方，然后学习率除以其根植，以此来自适应调整学习率。当之前的梯度大时，分母大，学习率变小；当之前的梯度小时，分母小，学习率变大。
  &lt;!-- ![Markdowm Image](/assets\Deep_Learning\image_34.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets/Deep_Learning\image_34.png&quot; alt=&quot;Markdowm Image&quot; /&gt;
  RMSProp 在Adagrad 的基础上将梯度平方的累加和改为梯度平方的滑动平均值。也实现自适应调整学习率，但是很远的梯度就考虑得很少。
  &lt;!-- ![Markdowm Image](/assets\Deep_Learning\image_35.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets/Deep_Learning\image_35.png&quot; alt=&quot;Markdowm Image&quot; /&gt;
  ADAM 使用梯度平方的滑动平均来自适应调整学习率，同时使用梯度的滑动平均值作为梯度。并且使用偏差修正。
  &lt;!-- ![Markdowm Image](/assets\Deep_Learning\image_36.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets/Deep_Learning\image_36.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;优化函数为什么不用sgd 而用adam，什么时候应该使用sgd，什么时候使用adam？&lt;/strong&gt;
  &lt;strong&gt;ADAM 的收敛速度比SGDM 快，但是收敛效果没有SGDM 好&lt;/strong&gt;，因为ADMD 中使用一定窗口内梯度平方的滑动平均来自适应的调整学习率，如果数据发生巨变，那么学习率就时大时小，引起学习率震荡，导致模型最终收敛效果变差，如果最终的全局最优点是一个平坦的极值点，那么ADAM 会在收敛后尝试跳出，使得最终的收敛效果变差。前期梯度平方滑动平均小，学习率大，ADAM 收敛更快，ADAM 更倾向于收敛到sharp minimum，因为这种极值点附近的梯度大，进来时梯度平方的滑动平均大，学习率小，然后收敛于此处。如果处于平坦的极值点，梯度的平方小，学习率大，算法尝试跳出平坦的极值点。平坦的极值点通常训练集和测试集分布更接近，SGDM 的泛化能力强一些，ADAM 最终收敛的泛化能力差一些。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;customname8&quot;&gt;8、训练中&lt;/h3&gt;

&lt;!-- ![Markdowm Image](/assets\Deep_Learning\image_4.png) --&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets/Deep_Learning\image_4.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Warm-up 作用？&lt;/strong&gt;
  在训练初期EMA 不稳定，此时让学习率小一些，待EMA 稳定以后，再选择预先设置的学习率进行训练&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Early-stopping 作用？&lt;/strong&gt;
  有降低过拟合的作用，但是提早停止，代价函数的优化就停止了，偏差就不再下降。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Learning rate decay 作用&lt;/strong&gt;
  在初期设置较大的学习率，然后逐渐减小学习率能加快训练速度。可以根据公式衰减，可以根据epoch 衰减，可以按照指定的离散值衰减。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Shuffling 作用&lt;/strong&gt;
  避免模型从数据顺序中学习到偏见&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;customname9&quot;&gt;9、可视化&lt;/h3&gt;

&lt;!-- ![Markdowm Image](/assets\Deep_Learning\image_3.png) --&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets/Deep_Learning\image_3.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;customname10&quot;&gt;10、评估&lt;/h3&gt;

&lt;!-- ![Markdowm Image](/assets\Deep_Learning\image_2.png) --&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets/Deep_Learning\image_2.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;准确率、召回率、F1 分数？&lt;/strong&gt;
  True positive ：positive 表示当前预测为正样本，True 表示预测对了，标签也是正样本。
  &lt;!-- ![Markdowm Image](/assets\Deep_Learning\image_37.png) --&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets/Deep_Learning\image_37.png&quot; alt=&quot;Markdowm Image&quot; /&gt;
  F1 分数介于0-1 直接，越高越好。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;偏差、方差和欠拟合、过拟合的关系？&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;customname11&quot;&gt;11、算法调整&lt;/h3&gt;

&lt;!-- ![Markdowm Image](/assets\Deep_Learning\image_1.png) --&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets/Deep_Learning\image_1.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;高偏差怎么调？&lt;/strong&gt;
  数据原因（特征不够）、网络结构原因（网络结构过于简单，使用更复杂的模型或者Boosting）、参数设置原因（学习率过小或过大）、损失函数原因（本身不收敛）、训练过程原因（训练次数太少，还没有收敛）&lt;br /&gt;
  Boosting：将训练集分为多个子集，每个子集都训练一个简单的模型，最后加权所有模型。无论怎么的输入，总有一个模型能预测很好，最终加权输出也很好。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;高方差怎么调？&lt;/strong&gt;
  数据原因（训练集和测试集分布差异大，用了过多不相关的特征。）、网络结构原因（网络结构过于复杂。简化结构、正则化、Dropout、BN、bagging）、训练过程原因（训练时间过长。early stopping）通常训练集和测试集分布差异大的原因是训练集太小。&lt;br /&gt;
  Bagging：训练多个模型，然后预测时平均多个模型预测的结果。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="blog" /><category term="CV" /><summary type="html">目录</summary></entry><entry><title type="html">traditional_Image_Processing</title><link href="http://localhost:4000/traditional_Image_Processing/" rel="alternate" type="text/html" title="traditional_Image_Processing" /><published>2022-12-21T23:38:00+08:00</published><updated>2022-12-21T23:38:00+08:00</updated><id>http://localhost:4000/traditional_Image_Processing</id><content type="html" xml:base="http://localhost:4000/traditional_Image_Processing/">&lt;h2 id=&quot;目录&quot;&gt;目录&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h3 id=&quot;1几何变换&quot;&gt;&lt;a href=&quot;#customname1&quot;&gt;1、几何变换&lt;/a&gt;&lt;/h3&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h3 id=&quot;2滤波&quot;&gt;&lt;a href=&quot;#customname2&quot;&gt;2、滤波&lt;/a&gt;&lt;/h3&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h3 id=&quot;3形态学&quot;&gt;&lt;a href=&quot;#customname3&quot;&gt;3、形态学&lt;/a&gt;&lt;/h3&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h3 id=&quot;4图像梯度&quot;&gt;&lt;a href=&quot;#customname4&quot;&gt;4、图像梯度&lt;/a&gt;&lt;/h3&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h3 id=&quot;5模版匹配&quot;&gt;&lt;a href=&quot;#customname5&quot;&gt;5、模版匹配&lt;/a&gt;&lt;/h3&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;customname1&quot;&gt;1、几何变换&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;缩放&quot;&gt;缩放&lt;/h4&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;!-- ![Markdowm Image](/assets\traditional_Image_Processing\image_3.png) --&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets/traditional_Image_Processing\image_3.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;翻转&quot;&gt;翻转&lt;/h4&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;仿射变换&quot;&gt;仿射变换&lt;/h4&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;!-- ![Markdowm Image](/assets\traditional_Image_Processing\image_4.png) --&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets/traditional_Image_Processing\image_4.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- https://www.cnblogs.com/shine-lee/p/10950963.html
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;透视变换&quot;&gt;透视变换&lt;/h4&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;!-- ![Markdowm Image](/assets\traditional_Image_Processing\image_5.png) --&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets/traditional_Image_Processing\image_5.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- https://blog.csdn.net/qq_36523492/article/details/109723705
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;重映射&quot;&gt;重映射&lt;/h4&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;参数估计&quot;&gt;参数估计&lt;/h4&gt;

    &lt;p&gt;通过变换前后的点对列线性方程，直接求解、基于最小二乘求解或者SVD分解求解等&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;customname2&quot;&gt;2、滤波&lt;/h3&gt;

&lt;!-- ![Markdowm Image](/assets\traditional_Image_Processing\image_1.png) --&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets/traditional_Image_Processing\image_1.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;customname3&quot;&gt;3、形态学&lt;/h3&gt;

&lt;!-- ![Markdowm Image](/assets\traditional_Image_Processing\image_2.png) --&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets/traditional_Image_Processing\image_2.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;customname4&quot;&gt;4、图像梯度&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;sobel&quot;&gt;Sobel&lt;/h4&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;!-- ![Markdowm Image](/assets\traditional_Image_Processing\image_6.png) --&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets/traditional_Image_Processing\image_6.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;laplacian&quot;&gt;Laplacian&lt;/h4&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;!-- ![Markdowm Image](/assets\traditional_Image_Processing\image_7.png) --&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets/traditional_Image_Processing\image_7.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;canny&quot;&gt;canny&lt;/h4&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;!-- ![Markdowm Image](/assets\traditional_Image_Processing\image_8.png) --&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets/traditional_Image_Processing\image_8.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;customname5&quot;&gt;5、模版匹配&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;sadsum-of-absolute-differences&quot;&gt;SAD：Sum of Absolute Differences&lt;/h4&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;!-- ![Markdowm Image](/assets\traditional_Image_Processing\image_9.png) --&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets/traditional_Image_Processing\image_9.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;ssdsum-of-squared-difference&quot;&gt;SSD：Sum of Squared Difference&lt;/h4&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;!-- ![Markdowm Image](/assets\traditional_Image_Processing\image_10.png) --&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets/traditional_Image_Processing\image_10.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;nccnormalization-cross-correlation&quot;&gt;NCC：Normalization Cross Correlation&lt;/h4&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;!-- ![Markdowm Image](/assets\traditional_Image_Processing\image_11.png) --&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets/traditional_Image_Processing\image_11.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;zncczero-mean-normalization-cross-correlation&quot;&gt;ZNCC：Zero-mean Normalization Cross Correlation&lt;/h4&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;!-- ![Markdowm Image](/assets\traditional_Image_Processing\image_12.png) --&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets/traditional_Image_Processing\image_12.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;</content><author><name></name></author><category term="blog" /><category term="CV" /><summary type="html">目录</summary></entry><entry><title type="html">Linux常用指令</title><link href="http://localhost:4000/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" rel="alternate" type="text/html" title="Linux常用指令" /><published>2022-12-20T17:13:00+08:00</published><updated>2022-12-20T17:13:00+08:00</updated><id>http://localhost:4000/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4</id><content type="html" xml:base="http://localhost:4000/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets/images/2022-12-20-Linux常用命令.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;</content><author><name></name></author><category term="blog" /><category term="Linux" /><summary type="html"></summary></entry><entry><title type="html">Perspective-n-Point 问题</title><link href="http://localhost:4000/Perspective-n-Point-%E9%97%AE%E9%A2%98/" rel="alternate" type="text/html" title="Perspective-n-Point 问题" /><published>2022-12-18T22:25:00+08:00</published><updated>2022-12-18T22:25:00+08:00</updated><id>http://localhost:4000/Perspective-n-Point%20%E9%97%AE%E9%A2%98</id><content type="html" xml:base="http://localhost:4000/Perspective-n-Point-%E9%97%AE%E9%A2%98/">&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yang-yang-o-o/yang-yang-o-o.github.io/main/assets/images/2022-12-18-Perspective-n-Point.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;</content><author><name></name></author><category term="blog" /><category term="SLAM" /><summary type="html"></summary></entry></feed>